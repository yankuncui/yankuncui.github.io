<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>timeline | Champion</title><meta name="author" content="cuiyankun"><meta name="copyright" content="cuiyankun"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="2021年6月4日  星期五  晴 ​                                                                                              克鲁斯卡尔算法求最小生成树 基本思想是：假设连通网G&#x3D;（V，E），令最小生成树的初始状态为只有n个顶点而无边的非连通图T&#x3D;（V，{}），图中每个顶点自成一个连通分量。在E中选">
<meta property="og:type" content="website">
<meta property="og:title" content="timeline">
<meta property="og:url" content="http://example.com/timeline/index.html">
<meta property="og:site_name" content="Champion">
<meta property="og:description" content="2021年6月4日  星期五  晴 ​                                                                                              克鲁斯卡尔算法求最小生成树 基本思想是：假设连通网G&#x3D;（V，E），令最小生成树的初始状态为只有n个顶点而无边的非连通图T&#x3D;（V，{}），图中每个顶点自成一个连通分量。在E中选">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg">
<meta property="article:published_time" content="2021-04-27T02:57:55.000Z">
<meta property="article:modified_time" content="2021-06-26T03:12:01.227Z">
<meta property="article:author" content="cuiyankun">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/timeline/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'timeline',
  isPost: false,
  isHome: false,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2021-06-26 11:12:01'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/tx.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">35</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/timeline/"><i class="fa-fw fa fa-bell"></i><span> 日志</span></a></div><div class="menus_item"><a class="site-page" href="/myself/"><i class="fa-fw fa fa-address-card"></i><span> 简历</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/math/"><i class="fa-fw fa fa-asterisk"></i><span> Math</span></a></li><li><a class="site-page child" href="/English/"><i class="fa-fw fa fa-font"></i><span> English</span></a></li><li><a class="site-page child" href="/politics/"><i class="fa-fw fa fa-book"></i><span> Politics</span></a></li><li><a class="site-page child" href="/408/"><i class="fa-fw fa fa-desktop"></i><span> FZE</span></a></li></ul></div></div></div></div><div class="page" id="body-wrap"><header class="not-home-page" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Champion</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/timeline/"><i class="fa-fw fa fa-bell"></i><span> 日志</span></a></div><div class="menus_item"><a class="site-page" href="/myself/"><i class="fa-fw fa fa-address-card"></i><span> 简历</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/math/"><i class="fa-fw fa fa-asterisk"></i><span> Math</span></a></li><li><a class="site-page child" href="/English/"><i class="fa-fw fa fa-font"></i><span> English</span></a></li><li><a class="site-page child" href="/politics/"><i class="fa-fw fa fa-book"></i><span> Politics</span></a></li><li><a class="site-page child" href="/408/"><i class="fa-fw fa fa-desktop"></i><span> FZE</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="page-site-info"><h1 id="site-title">timeline</h1></div></header><main class="layout" id="content-inner"><div id="page"><div id="article-container"><p>2021年6月4日  星期五  晴</p>
<p>​                                                                                              <strong>克鲁斯卡尔算法求最小生成树</strong></p>
<p>基本思想是：假设连通网G=（V，E），令最小生成树的初始状态为只有n个顶点而无边的非连通图T=（V，{}），图中每个顶点自成一个连通分量。在E中选择代价最小的边，若该边依附的顶点分别在T中不同的连通分量上，则将此边加入到T中；否则，舍去此边而选择下一条代价最小的边。依此类推，直至T中所有顶点构成一个连通分量为止 。</p>
<p>具体实例1：</p>
<p>求下图的最小生成树</p>
<p><img src="https://cdn.jsdelivr.net/gh/yankuncui/pictures/img/ACF4AE57219A300CCC3CC2740C43C5CE.jpg" alt="img"></p>
<p>解：构造连通无圈的图，即最小生成树，用克鲁斯卡尔算法：</p>
<p>​       第一步：取ab=1; 第二步：取af=4</p>
<p>​       第三步：取fe=3; 第四步：取ad=9</p>
<p>​       第五步：取bc=23</p>
<p>  如图所示，总权值为1+4+3+9+23=40</p>
<p><img src="https://cdn.jsdelivr.net/gh/yankuncui/pictures/img/15848287D972B9F4C99C1458631656ED.jpg" alt="img"></p>
<p>具体实例2：</p>
<p>求下图的最小生成树</p>
<p><img src="https://cdn.jsdelivr.net/gh/yankuncui/pictures/img/ECA0B74D1759530720888F3FFC8AC00F.jpg" alt="img"></p>
<p>解：第一步：取最小权1的边ac</p>
<p>​        第二步：取剩余最小权1的边ce</p>
<p>​        第三步：取剩余最小权且不与前面的边构成回路2的边ab</p>
<p>​        第四步：取剩余最小权且不与前面的边构成回路3的边bd，五个字母全部出现就结束</p>
<p>如图所示，总权值为1+2+3+1=7</p>
<p><img src="https://cdn.jsdelivr.net/gh/yankuncui/pictures/img/EECDF436559FFE2F44BE03854021E92F.jpg" alt="img"></p>
<p>​                                                                                     <strong>普利姆算法求最小生成树</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/yankuncui/pictures/img/76AADD936B6B2A903FF3B2A0ED40A52B.jpg" alt="img"></p>
<hr>
<p>2021年6月5日   星期六      晴                                                                            </p>
<p>​                                                                                 <strong>迪杰斯特拉算法求最短路径</strong></p>
<p><strong>迪杰斯特拉算法的求解过程</strong></p>
<p>对于网N=(V,E),将N中的顶点分成两组</p>
<p>第一组S：已求出的最短路径的终点集合(初始时只包含源点v0)</p>
<p>第二组V-S：尚未求出的最短路径的终点集合(初始时为V-{v0})</p>
<p>算法将按各顶点与v0间最短路径递增的次序，逐个将集合V-S中的顶点加入到集合S中去。在这个过程中，总保持从v0到集合S中各顶点的路径长度始终不大于到集合V-S中各顶点的路径长度。</p>
<p><strong>迪杰斯特拉算法步骤</strong></p>
<p>初始化</p>
<ul>
<li>将源点v0加入到S中，即S[v0]=true;</li>
<li>将v0到各个终点的最短路径长度初始化为权值，即D[i]=G.arcs [v0] [vi],(vi属于V-S);</li>
<li>如果v0到顶点vi之间有弧，则将vi的前驱置为v0，即Path[i]=v0,否则Path[i]=-1。</li>
</ul>
<p>循环n-1次，执行以下操作</p>
<ul>
<li><p>选择一条最短路径的终点vk，使得：</p>
<p>​             D[k]=Min{D[i]|vi属于V-S}</p>
</li>
<li><p> 将vk加入到S中，即S[vk]=true;</p>
</li>
<li><p>根据条件更新从v0出发到集合V-S上任一顶点的最短路径的长度，若条件D[K]+G.arcs[k] [i]&lt;D[i]成立，则更新D[i]=D[K]+G.arcs[k] [i],同时更改vi的前驱为vk;Path[i]=k。</p>
</li>
</ul>
<p><strong>通俗理解迪杰斯特拉算法</strong></p>
<p>1.迪杰斯特拉算法的第一步就是先创建3个数组或集合分别用来记录已访问的顶点(用V表示)，出发顶点到其余各顶点的距离(用D表示），和各顶点的前驱顶点(用P表示)<br>2.上面做好之后从出发顶点开始(如上图中的G就是出发顶点)，遍历出发顶点到其余各个顶点的距离(不直达可以用一个较大的整数表示)，然后把这些信息记录到第一步的3个数组或者集合中。<br>3.第三步，从第一步的记录距离的集合中选取一个没有被访问顶点且距离最小的顶点开始，继续遍历该顶点（如：顶点n，下面以n举例）到其他顶点(比如：下标为m的顶点，下面以m举例)的距离(已访问过的顶点除外)。得到从该顶点到<br>4.接着第3步，如果： 出发顶点到m的距离 + 从m到n的距离 &gt; 从出发顶点到n的距离(也就是距离表记录的距离) ，那么就把：出发顶点到m的距离 + 从m到n的距离 更新到距离表中，表示从出发顶点到n顶点的距离最小，同时更新第一步中的V数组和P数组（更新n为已访问顶点，更新m的前驱为n）<br>5.重复第3步和第4步，直到把集合V都更新为已访问为止。</p>
<p>具体实例：某单位建设局域网需要铺设光缆，光缆连接的建筑物的位置、建筑物之间可以铺设光缆的线路及线路的长度如下图所示。问：如何铺设才能使光缆的总长度最短？</p>
<p><img src="https://cdn.jsdelivr.net/gh/yankuncui/pictures/img/542B8EE8DA1A21BA5C86DFABCEF26EBD.jpg" alt="542B8EE8DA1A21BA5C86DFABCEF26EBD"></p>
<p>解：</p>
<p><img src="https://cdn.jsdelivr.net/gh/yankuncui/pictures/img/B88E2466556BEA0C3FF0C2980BF5CECB.jpg" alt="img"></p>
<hr>
<p>2021年6月6日   星期日     晴</p>
<p>​                                                                                     <strong>软件构造相关复习内容</strong></p>
<p><strong>瀑布模型</strong></p>
<p>瀑布模型把软件生命周期划分为八个阶段：问题的定义、可行性研究、软件需求分析、系统总体设计、详细设计、编码、测试和运行、维护，八个阶段又可归纳为三个大的阶段：计划阶段、开发阶段、运行阶段。</p>
<p>在瀑布式开发过程中，按照软件生存周期，把开发分为制定计划、需求分析、软件设计、程序编写、软件测试和运行维护这6个基本活动，并规定了他们自上而下、相互衔接的固定次序，如同瀑布流水、逐级下落。</p>
<p>在瀑布模型中，软件开发的各项活动严格按照线性方式进行，当前活动接受上一项活动的工作结果，实施完成所需的工作内容。<strong>瀑布模型的核心思想就是按工序将问题化简，将功能的实现和设计分开，便于分工协作，即采用结构化的分析与设计方法将逻辑实现与物理实现分开。</strong></p>
<p>主要问题(缺点)</p>
<ol>
<li>阶段划分僵硬，每个阶段都不能缺省，而且产生大量文档，增加了工作量；</li>
<li>开发是线性的，只有等到整个过程的末期才能见到开发结果—-可运行软件，不利于快速响应变化的需求；</li>
<li>早期的错误要等到开发后期的测试阶段才能发现，可能带来严重的后果，增加了开发的风险；</li>
</ol>
<p>在结构化的瀑布模型中，<strong>需求分析阶段</strong>定义的标准将成为软件测试年勺系统测试阶段的目标。</p>
<p>适用于面向对象方法学的软件生存周期模型是<strong>喷泉模型</strong></p>
<p><strong>增量开发模型</strong></p>
<p>增量开发是指待开发的软件不是一次就能完成的，而是把软件分成一系列增量，完成一部分就交付一部分，对每个增量的使用和评估都作为下一个增量发布的新特征和功能。增量开发模型本质上就是迭代开发的，迭代指的是不是一次性执行软件开发的全部活动，而是有计划的反复执行“分析-设计-编码-测试”这样一组过程。<strong>增量模型的基本思想就是让开发者能够从早期的开发、系统的增量、交付的版本中学到的经验</strong></p>
<p>主要优点</p>
<ol>
<li>在短时间内向用户提交一个可运行软件，能够提供解决用户急用的一些功能；</li>
<li>由于每次只提交部分功能，用户有较充分的时间学习和适应新的产品；</li>
<li>在开发过程中，需求的变化是不可避免的。增量开发模型的灵活性可以使软件适应需求的变化；</li>
<li>有利于系统维护，因为整个系统是由一个个增量集成在一起，当需求变更时，只需更改部分，不必影响整个系统；</li>
</ol>
<p>主要风险(缺点)</p>
<ol>
<li>由于各个部件是逐渐并入已有软件的，必须确保每次增加的部件不破坏已构造好的系统，这需要软件具备开放式的体系结构，否则系统将失去稳定的结构</li>
<li>逐步增加部件的方式，很容易退化为边做边改模型，从而使软件失去整体性</li>
</ol>
<p><strong>软件的生存周期</strong></p>
<p>概念：一个软件产品或软件系统经历孕育、诞生、成长、成熟、衰亡等阶段。</p>
<p>使用角度的软件生存周期</p>
<p>从用户的角度</p>
<p>软件的生存周期可以分为下列三个阶段：提出需求、获取软件、使用软件。</p>
<p>开发角度的软件生存周期</p>
<p>从软件开发者的角度</p>
<p>软件的生存周期可以分为下列三个阶段：定义软件、开发软件、维护软件。</p>
<p><strong>软件设计</strong></p>
<p>经典的软件工程把软件分为概要设计和详细设计。按照软件的组成，可以进行系统架构设计、子系统及构件设计、接口设计及算法设计和数据结构的程序设计。另外，软件还可以进行功能设计、用户界面设计和数据库设计。</p>
<p>软件实现与通常的程序设计的主要区别时软件的集成与测试，软件的集成是指通过函数调用、消息传递、事件响应、状态改变、服务合成等机制把把编程实现的各个软件单元组装在一起，形成一个更大的软件单元或可以运行的软件系统。</p>
<p><strong>软件测试</strong></p>
<p>单元测试：对程序基本组成单元的测试。</p>
<p>集成测试：对软件组装结果的测试。</p>
<p>系统测试：对整个软件系统的测试。</p>
<p>验收测试：把软件交付给用户时的测试。</p>
<p>单元测试一般以<strong>白盒测试</strong>为主，<strong>黑盒测试</strong>为辅。</p>
<p>在白盒法技术测试用例的设计中<strong>语句</strong>是最弱的覆盖标准。</p>
<p><strong>软件维护</strong></p>
<ol>
<li>改正性维护：修正出现的软件缺陷。缺陷交付使用后，会有一部分隐藏的错误被带到运行阶段，这些隐藏的错误在某些特定的使用环境下就会暴露，必须消除。</li>
<li>适应性维护：为适应环境的变化而进行的软件修改活动。</li>
<li>完善性维护：为满足不断变化的需求而改善和加强产品的功能与性能。</li>
<li>预防性维护：为完善软件系统的可维护性和可靠性。也为以后的改进奠定基础。</li>
</ol>
<p><strong>敏捷开发</strong></p>
<p>敏捷开发是应对快速变化的需求的一种软件开发能力。以用户的需求进化为核心，采用迭代、循序渐进的方法进行软件开发。敏捷开发就是把一个项目分为多个相互联系、但也可独立运行的小项目，分别完成，在此过程中，软件一直处于可使用状态。</p>
<p>敏捷技术遵循软件开发的基本原则，如抽象、模块内聚、模块之间松散耦合、信息隐藏等，敏捷开发主要采用面向对象的开发技术，敏捷开发使用UML的符号主要是类图和时序图。</p>
<p><strong>软件构造</strong></p>
<p>软件构造指的是通过编码、验证、单元测试、集成测试和调试的组合，详细的创建可工作的、有意义的软件。</p>
<p><strong>类之间的关系</strong></p>
<p>一、继承(普通与特殊)，即“是一种”关系。例如：加法算式是一种二元算式；</p>
<p>二、聚合(整体与个体),即成员关系，例如：算式是习题的一部分;</p>
<p>三、关联，表示没有其他关系的类之间的某种语义依赖，例如：学生和教师是两个独立的类，但他们都与课程有关。</p>
<p>四、依赖，依赖关系是类与类之间的联接，一个类依赖与另一个类的定义，例如：一个人看书，人这个类依赖于书这个类。</p>
<p>五、组合(整体与部分),相比于聚合，组合是一种耦合更强的关联关系，组合关系是整体-部分，部分单独存在没有意义</p>
<p>六、实现，实现是指一个类实现一个接口</p>
<p><strong>面向对象的设计符号</strong></p>
<p>UML图</p>
<p>在UML中，类是用一个带有类名、可选属性和操作矩形表示，分割线用来分割类名、属性和操作。类名在矩形的最上方，其次是属性，然后是方法。约定，具体类的名称正常书写：抽象类在类名前加abstract前缀，或用斜体书写。属性类似程序语言的说明-可见性、变量名、类型、初始值，用前缀表示可见性：”+”表示公用的，”-“表示私有的，”#”表示保护的。静态变量或常量用大写字母的标识符，成员变量允许具有初始值。操作用签名表示-可见性、返回类型、操作名、参数及类型，可见性符号与属性的相同。</p>
<p>如图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/yankuncui/pictures/img/I$T1%5B%60_VK4~UP1BOLYA9%5BCU.png" alt="img"></p>
<p>还有标示类名的矩形表示类UML图用来表示类之间的关系</p>
<p>类之间的关联用一根线表示，可以包括每个关联类的角色名、数目、方向和约束。泛化关系是指一端带有空心三角形的连线，绘制时从子类到父类，空心三角形一端是父类。有两种表示整体-部分的特殊关联-聚合和组合，聚合的整体端用空心菱形表示，组和的整体端用实心菱形表示。</p>
<p>如图所示：<br><img src="https://cdn.jsdelivr.net/gh/yankuncui/pictures/img/B9530988A6A02C479F050A937248F9F3.jpg" alt="img"></p>
<p>接口：空心圆+直线（唐老鸭类实现了‘讲人话’）；<br>依赖：虚线+箭头（动物和空气的关系）；<br>关联：实线+箭头（企鹅需要知道气候才迁移）；<br>聚合：空心四边形+实线+箭头（雁群和大雁的关系）；<br>合成/组合：实心四边形+实线+箭头（鸟和翅膀的关系）；<br>泛化/继承：空心三角形+实线（动物和鸟的继承关系）；<br>实现：空心三角形+虚线（实现大雁飞翔的接口）；</p>
<p>具体实例1：某一新闻管理系统主要用来发布新闻，管理员只有一个，登录后可以在后台发布新闻，任何人可以浏览新闻，浏览者可以注册成为系统会员，注册后可对新闻进行评论。管理员在后台可以对新闻、评论、注册会员进行管理，如修改删除等。</p>
<p>要求：请画出该新闻管理系统的用例图</p>
<p><img src="https://cdn.jsdelivr.net/gh/yankuncui/pictures/img/1B604EAF3CA1F14B08CF421128D47527.jpg" alt="img"></p>
<p>具体实例2： 为某企业建立一个人事管理系统。有以下需求：  总经理可创建部门、撤销部门、更改部门的名称、安排部门经理，也能对人员指派部门；  人事部门的工作人员可建立员工的人事档案，应包括身份证号、姓名、性别、出生日期等；  部门经理可为本部门添加新员工、确定员工的工资、也可解除本部门的特定员工；  员工可修改自己的个人信息，如联系电话、Email等，也可查看本部门的其他员工的信息。 根据以上描述，结合常识和逻辑推理，建立用例图来表示系统的功能。<br><img src="https://cdn.jsdelivr.net/gh/yankuncui/pictures/img/967622144A91F5CEB210E8F601FE83DE.jpg" alt="img"></p>
<p>具体实例3： 某大学教务部计划采用计算机管理学生选课的过程，以帮助管理人员更快、更好的做好选课管理工作。其功能如下：  教务处课程管理人员显示本学期可以选择的课程；  学生选课完毕后，学校的财务系统记录学生的缴费金额  在选定后的一段时间内，学生可以添加、删除选定的课程。  教师可以通过选课系统得到选修自己课程的学生名单。  学生和教师登录时需要验证。 在需求分析阶段，采用UML的用例图描述该系统的功能需求。  </p>
<p><img src="https://cdn.jsdelivr.net/gh/yankuncui/pictures/img/A757C163C83D781D8B81260B5A2D7043.jpg" alt="img"></p>
<p><strong>GUI软件构造</strong></p>
<p>在Swing中，窗口是一种容器类，而且是顶层容器类，顶层容器就是可以容纳其他容器或组件、本身可以独立显示、不依赖其他容器类的类，对话框是另一个与窗口类似的顶层容器类，对话框用于交互，菜单包括菜单条(JMenuBar)、菜单(JMenu)、菜单项(JMenuItem)，菜单条是一个是一个容器类，但不是顶层容器，工具条是一个容器类，可以放置各种常用的工具或组件</p>
<p><strong>GUI基本设计规范</strong></p>
<ul>
<li>界面合理</li>
<li>风格一致</li>
<li>元素标准<ul>
<li>窗口与对话框的标准</li>
<li>菜单和工具条的标准</li>
<li>图标的标准</li>
<li>基本组件的标准</li>
</ul>
</li>
</ul>
<p><strong>GUI的设计原则</strong></p>
<ol>
<li>关注用户及其任务，而不是技术</li>
<li>首先考虑功能，然后才是表示</li>
<li>对任务的看法与用户保持一致</li>
<li>设计要符合常见情况</li>
<li>不要分散用户对目标的注意力</li>
<li>促进学习</li>
<li>传递信息，而不仅仅是数据</li>
<li>设计应满足响应需求</li>
<li>通过用户试用发现并改正错误</li>
</ol>
<p><strong>应用数据库</strong></p>
<p>方法executeQuery<br>用于产生单个结果集的语句，例如 SELECT 语句。 被使用最多的执行 SQL 语句的方法是 executeQuery。这个方法被用来执行 SELECT 语句，它几乎是使用最多的 SQL 语句。 </p>
<p>方法execute：<br>用于执行返回多个结果集、多个更新计数或二者组合的语句。因为多数程序员不会需要该高级功能 </p>
<p>方法executeUpdate<br>用于执行 INSERT、UPDATE 或 DELETE 语句以及 SQL DDL（数据定义语言）语句，例如 CREATE TABLE 和 DROP TABLE。INSERT、UPDATE 或 DELETE 语句的效果是修改表中零行或多行中的一列或多列。executeUpdate 的返回值是一个整数，指示受影响的行数（即更新计数）。对于 CREATE TABLE 或 DROP TABLE 等不操作行的语句，executeUpdate 的返回值总为零。 </p>
<p><strong>prepareStament与createStatement的区别</strong></p>
<p>1：在概念上<br>prepareStatement会先初始化SQL，先把这个SQL提交到数据库中进行预处理，多次使用可提高效率。  </p>
<p>createStatement不会初始化，没有预处理，每次都是从0开始执行SQL。</p>
<p>2：在变量上</p>
<p>prepareStatement可以在SQL中用?替换变量</p>
<p>String sql = “insert into category values(null,?,?)”;</p>
<p>createStatement不支持 ? 替换变量，只能在sql中拼接参数</p>
<p>String sql = “delete from category where id = “ + id ;</p>
<p> 3：功能上<br> 如果想要删除三条数据</p>
<p> 对于createStatement，需要写三条语句<br>   String sql = “delete from category where id = 2” ;<br>   String sql = “delete from category where id = 3” ;<br>   String sql = “delete from category where id = 7” ;<br>   复制代码<br> 而prepareStatement，通过set不同数据只需要生成一次执行计划，可以重用</p>
<p>   String sql = “delete from category where id = ？” ;</p>
<p>1.PreparedStatement是预编译的,对于批量处理可以大大提高效率.也叫JDBC存储过程。</p>
<p>2.使用createStatement 对象。在对数据库只执行一次性存取的时侯，用 createStatement对象进行处理。PreparedStatement对象的开销比createStatement大，对于一次性操作并不会带来额外的好处。</p>
<p>3.createStatement每次执行sql语句，相关数据库都要执行sql语句的编译，preparedstatement是预编译得,preparedstatement支持批处理</p>
<p>4:可重复性</p>
<p>对于上面的两段代码而言：第一段 id 必须给定一个值</p>
<p>而第二段中，对象的key，value都可以自己定义，而且大多数情况下这个语句已经被预编译过，因而当其执行时，只需DBMS运行SQL语句，而不必先编译。</p>
<p>这种转换也给你带来很大的便利，不必重复SQL语句的句法，而只需更改其中变量的值，便可重新执行SQL语句。</p>
<p>选择PreparedStatement对象与否，在于相同句法的SQL语句是否执行了多次，而且两次之间的差别仅仅是变量的不同。如果仅仅执行了一次的话，它应该和普通的对象毫无差异，体现不出它预编译的优越性。</p>
<p>有关JAVA连接数据库的代码可以参考<a target="_blank" rel="noopener" href="https://yankuncui.github.io/2021/04/26/Java%E9%A1%B9%E7%9B%AE%E4%B9%8B%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/">https://yankuncui.github.io/2021/04/26/Java%E9%A1%B9%E7%9B%AE%E4%B9%8B%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/</a></p>
<p><strong>软件复用</strong></p>
<p>软件复用是指在两次或多次不同的软件开发过程中重复使用相同或相近的软件或软件板块的过程。软件复用包括产品复用与过程复用</p>
<p>软件复用的优点</p>
<ol>
<li>提高生产率</li>
<li>减少维护代价</li>
<li>提高互操作性</li>
<li>支持快速原型</li>
</ol>
<p>软件复用应解决的三个问题</p>
<ol>
<li>必须有可复用的对象</li>
<li>所复用的对象必须是有用的</li>
<li>复用者需要知道如何使用被复用的对象</li>
</ol>
<p><strong>工厂模式</strong></p>
<p>工厂方法模式（FACTORY METHOD）是一种常用的类创建型设计模式,此模式的核心精神是封装类中变化的部分，提取其中个性化善变的部分为独立类，通过依赖注入以达到解耦、复用和方便后期维护拓展的目的。它的核心结构有四个角色，分别是抽象工厂；具体工厂；抽象产品；具体产品</p>
<p><strong>角色结构</strong></p>
<p>抽象工厂(Creator)角色：是工厂方法模式的核心，与应用程序无关。任何在模式中创建的对象的工厂类必须实现这个接口。<br>具体工厂(Concrete Creator)角色：这是实现抽象工厂接口的具体工厂类，包含与应用程序密切相关的逻辑，并且受到应用程序调用以创建产品对象。<br>抽象产品(Product)角色：工厂方法模式所创建的对象的超类型，也就是产品对象的共同父类或共同拥有的接口。<br>具体产品(Concrete Product)角色：这个角色实现了抽象产品角色所定义的接口。某具体产品有专门的具体工厂创建，它们之间往往一一对应。</p>
<p>工厂方法模式结构</p>
<ul>
<li>工厂是工厂方法模式的核心，它负责实现创建所有实例的内部逻辑。工厂类的创建产品类的方法可以被外界直接调用，创建所需的产品对象</li>
<li>抽象产品是所创建的所有对象的父类，它负责描述所有实例所共有的公共接口</li>
<li>具体产品是工厂模式的创建目标，所有创建的对象都是充当这个角色的某个具体类的实例</li>
</ul>
<p>工厂方法模式的实质就是一个工厂类根据传入的参数，动态决定应该创建哪一个产品类(这些产品类继承自一个父类或接口的实例)</p>
<p>工厂方法的核心思想：简单工厂模式的核心思想就是：有一个专门的类来负责创建实例的过程。具体来说，把产品看着是一系列的类的集合，这些类是由某个抽象类或者接口派生出来的一个对象树。而工厂类用来产生一个合适的对象来满足客户的要求。如果简单工厂模式所涉及到的具体产品之间没有共同的逻辑，那么我们就可以使用接口来扮演抽象产品的角色；如果具体产品之间有功能的逻辑或，我们就必须把这些共同的东西提取出来，放在一个抽象类中，然后让具体产品继承抽象类。为实现更好复用的目的，共同的东西总是应该抽象出来的。</p>
<p><strong>简单工厂模式的优缺点分析：</strong> </p>
<p>   优点：工厂类是整个模式的关键所在。它包含必要的判断逻辑，能够根据外界给定的信息，决定究竟应该创建哪个具体类的对象。用户在使用时可以直接根据工厂类去创建所需的实例，而无需了解这些对象是如何创建以及如何组织的。有利于整个软件体系结构的优化。</p>
<p>   缺点：由于工厂类集中了所有实例的创建逻辑，这就直接导致一旦这个工厂出了问题，所有的客户端都会受到牵连；而且由于简单工厂模式的产品室基于一个共同的抽象类或者接口，这样一来，但产品的种类增加的时候，即有不同的产品接口或者抽象类的时候，工厂类就需要判断何时创建何种种类的产品，这就和创建何种种类产品的产品相互混淆在了一起，违背了单一职责，导致系统丧失灵活性和可维护性。而且更重要的是，简单工厂模式违背了“开放封闭原则”，就是违背了“系统对扩展开放，对修改关闭”的原则，因为当我新增加一个产品的时候必须修改工厂类，相应的工厂类就需要重新编译一遍。</p>
<hr>
<p>2021年6月7日  星期一  晴</p>
<p>​                                                                                      <strong>数据结构相关复习内容</strong></p>
<p>数据结构是相互之间存在一种或多种特定关系的数据元素的集合。</p>
<p>数据元素时、是数据的基本单位。</p>
<p>数据项是组成数据元素、有独立含义的、不可分割的最小单位。</p>
<p>数据对象是性质相同的数据元素的集合。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yankuncui/pictures/img/7F94E84D5AF95F75A898095C86449782.jpg" alt="img"></p>
<p>存储结构分为顺序存储结构与链式存储结构</p>
<p><strong>算法的时间复杂度</strong></p>
<p>算法的时间复杂度定义：算法中基本语句重复执行的次数是问题规模n的某个函数f(n)，算法的时间量度记作T(n)=O(f(n)),它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称时间复杂度。</p>
<p>求时间复杂度具体实例1：</p>
<p>(1) x=0;y=0;</p>
<p>(2) for(k=1;k&lt;=n;k++)</p>
<p>(3)        x++;</p>
<p>(4) for(i=1;i&lt;=n;i++)</p>
<p>(5)   for(j=1;j&lt;=n;j++)</p>
<p>(6)        y++;</p>
<p>以上程序段中频度最大的语句是(6)，f(n)=n^2,所以时间复杂度为O(n^2)。</p>
<p>求时间复杂度具体事例2:</p>
<p>for(i=1;i&lt;=n;i=i*2){x++;s=0}</p>
<p>设循环体内两条基本语句的频度为f(n)，则有2^f(n)&lt;=n,f(n)&lt;=log2^n,所以该算法的时间复杂度为T(n)=O(log2^n)。</p>
<p><strong>算法的空间复杂度</strong></p>
<p>关于算法的存储空间要求，类似于算法的时间复杂度，我们采用渐近空间复杂度作为算法所需存储空间的量度，简称空间复杂度，它也是问题规模n的函数，记作：S(n)=O(f(n))</p>
<p><strong>线性表</strong></p>
<p>线性表的顺序存储</p>
<p>假设线性表的每个元素需占用l个存储单元，并以所占的第一个单元的存储地址作为数据元素的存储起始位置。则线性表中第i+1个数据元素的存储起始位置。则线性表中第i+1个数据元素的存储位置LOC(ai+1)和第i个数据元素的存储位置LOC(ai)之间满足下列关系：</p>
<p>​                                                        LOC(ai+1)=LOC(ai)+l</p>
<p>一般来说，线性表的第i个数据元素ai 的存储位置为:</p>
<p>​                                                       LOC(ai)=LOC(a1)+(i-1)Xl</p>
<p>线性表的链式存储</p>
<p>线性表的链式存储的特点：用一组任意的存储单元存储线性表的数据元素(这组存储单元可以是连续的，也可以是不连续的)</p>
<p>它包含两个域：其中存储的信息称为数据域，存储直接后继存储位置的域称为指针域。</p>
<p>链表的特点</p>
<ol>
<li>插入删除操作不需要移动元素</li>
<li>不必事先估算存储空间</li>
<li>所需空间与线性表长度成正比</li>
</ol>
<p>链表增加头结点的作用</p>
<ol>
<li><p>便于首元结点的处理</p>
<p>增加了头结点后，首元结点的地址保存在头结点(即前驱结点)的指针域中，则对链表的第一个数据元素的操作与其他数据元素相同，无需进行特殊处理</p>
</li>
<li><p>便于空表与非空表的统一处理、</p>
<p>当链表不设头结点时，假设L为单链表的头指针，它应该指向首元结点，则单链表为长度n为0的空表，L指针为空(判断空表的条件可记为：L==NULL)</p>
</li>
</ol>
<p><strong>栈和队列</strong></p>
<p>栈属于后进先出，而队列属于先进先出</p>
<p>队空的条件：Q.front=Q.rear</p>
<p>队满的条件：(Q.rear+1)%MAXQSIZE=Q.front</p>
<p>求队列长度：(Q.rear-Q.front+maxsize)%maxsize<br><strong>利用栈解决表达式求值问题</strong></p>
<p>算法思路:</p>
<p>首先置操作数栈为空栈，表达式起始符为“#”为栈底元素。依次读入表达式中的每个字符，若是操作数则进OPND栈，若是运算符则和OPTR栈的栈顶运算符比较优先权作相应操作，直至整个表达式求值完毕（OPTR栈顶元素和当前读入的字符均为“#”）</p>
<p>算法步骤:</p>
<ol>
<li><p>初始化OPTR栈与OPND栈，将起始符#压入OPTR栈。</p>
</li>
<li><p>扫描表达式，读入第一个字符ch，如果表达式没有扫描完毕至#或OPTR的栈顶元素不为#时，则循环执行以下操作：</p>
<ul>
<li>若ch不是运算符，则压入OPND栈，读入下一个字符ch；</li>
<li>若ch是运算符，则根据OPTR的栈顶元素和ch的优先级比较结果，做不同的处理：<ul>
<li>若是小于，则ch压入OPTR栈，读入下一个字符ch;</li>
<li>若是大于，则弹出OPTR栈顶的运算符，从OPND栈弹出两个数，进行相关计算，结果压入OPND栈；</li>
<li>若是等于，则OPTR的栈顶元素是左括号且ch是 右括号，这是弹出的OPTR栈顶的左括号，相当于括号匹配成功，然后读入下一字符ch。</li>
</ul>
</li>
</ul>
</li>
<li><p>OPND栈顶元素即为表达式求值结果，返回此元素。</p>
</li>
</ol>
<p><strong>利用队列解决舞伴问题</strong></p>
<p>算法步骤：</p>
<ol>
<li>初始化Mdancers队列与Fdancers 队列。</li>
<li>反复循环，依次将跳舞者根据其性别插入Mdancers队列或Fdancers队列。</li>
<li>当Mdancers队列和Fdancers队列均为非空时，反复循环，依次输出男女舞伴的姓名。</li>
<li>如果Mdancers队列为空而Fdancers队列非空，则输出Fdancers队列的队头女士的姓名。</li>
<li>如果Fdancers队列为空而Mdancers队列非空，则输出Mdancers队列的队头男士的姓名。</li>
</ol>
<p><strong>链式存储统计元素个数</strong></p>
<p>算法步骤：</p>
<ol>
<li>将链表头结点地址作为参数</li>
<li>声明链表结点指针并指向链表第一个节点</li>
<li>遍历链表并通过整型变量计数</li>
<li>返回结点个数</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">具体实现代码</span><br><span class="line"></span><br><span class="line">&#x2F;* 单链表数据结构 *&#x2F;</span><br><span class="line">typedef struct lNode &#123;</span><br><span class="line">    elemType data;</span><br><span class="line">    struct lNode *next;</span><br><span class="line">&#125; lNode, *linkList;</span><br><span class="line"> </span><br><span class="line">&#x2F;* 获取单链表长度 *&#x2F;</span><br><span class="line">&#x2F;* 初始条件：单链表L已存在。操作结果：返回L中数据元素个数 *&#x2F;</span><br><span class="line">int listLength (linkList L) &#123;</span><br><span class="line">    int i &#x3D; 0;</span><br><span class="line">    linkList p &#x3D; L-&gt;next; &#x2F;* p指向第一个结点 *&#x2F;</span><br><span class="line">     </span><br><span class="line">    while (p) &#123; &#x2F;* 没到表尾 *&#x2F;</span><br><span class="line">        i++;</span><br><span class="line">        p&#x3D;p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    return i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>串(模式匹配)</strong></p>
<p>串是由零个或多个字符组成的有限序列，一般记为s=”a1,a2,a3,a4….an”(n&gt;=0)</p>
<p>两个串相等是长度相等且对应位置的字母也相等。</p>
<p><strong>串的模式匹配算法</strong></p>
<p><strong>BF模式匹配算法</strong></p>
<p>算法步骤：</p>
<ol>
<li><p>分别利用计数指针i和j指示主串S和模式T中当前正待比较的字符位置，i初始值为pos，j的初值为1。</p>
</li>
<li><p>如果两个串均为比较到串尾，即i和均小于等于S和T的长度时，则循环执行以下操作：</p>
<ul>
<li>S.ch[i]和T.ch[j]比较，若相等，则i和 j分别指示串中下个位置，继续比较后续字符；</li>
<li>若不等，指针后退重新开始匹配，从主串的下一个字符(i=i-j+2)起在重新和模式的第一个字符(j=1)比较。</li>
</ul>
<p>3.如果j&gt;T.lenth,说明模式T中的每个字符依次和主串S中的一个连续的字符序列相等，则匹配成功，返回和模式T中第一个字符相等的字符在主串S中的序号(i-T.lenth);否则称匹配不成功，返回0</p>
</li>
</ol>
<p>具体代码可参考：<a target="_blank" rel="noopener" href="https://yankuncui.github.io/2021/04/16/BF/">https://yankuncui.github.io/2021/04/16/BF/</a></p>
<p><strong>KMP模式匹配算法</strong></p>
<p>与BF算法极为相似，不同之处在于：当匹配过程中产生失配时，指针i不变，指针j退回到next[j]所指示的位置上重新进行比较，并且当指针j退至为0时。指针i和指针 j需同时增1。即若主串的第i个字符和模式的第一个字符不等，应从主串的第i+1个字符起重新进行匹配。</p>
<p>具体代码可参考：<a target="_blank" rel="noopener" href="https://yankuncui.github.io/2021/04/16/KMP/">https://yankuncui.github.io/2021/04/16/KMP/</a></p>
<p><strong>next数组求值</strong></p>
<p>举例如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/yankuncui/pictures/img/yyy.jpg" alt="yyy"></p>
<p><strong>nextval数组求值</strong></p>
<p>规则如下：j=1时，nextval[j]=0</p>
<p>j&gt;1时,若pj不等于pnext[j],nextvar[j]=next[j]</p>
<p>若pj=pnext[j],nextval[j]=nextval[next[j]]</p>
<p>Pj就是模式串中字符对应的位置</p>
<p><img src="https://cdn.jsdelivr.net/gh/yankuncui/pictures/img/000.jpg" alt="000"></p>
<p><strong>二维数组存储计算问题</strong></p>
<p>如果按行序</p>
<p>LOC(i,j)=LOC(0,0)+(nXi+j)Xl</p>
<p>如果按列序</p>
<p>LOC(i,j)=LOC(0,0)+(nXj+i)Xl</p>
<p>注意：i为行，j为列</p>
<p><strong>广义表</strong></p>
<p>能根据图看出GetHead(A)与GetTail(A)</p>
<p>取表头(GetHead(LS)):取出的表头为非空广义表的第一个元素，它可以是一个单原子，也可以是一个子表。</p>
<p>取表尾(GetTail(LS)):取出的表尾为出去表头之外，由其余元素构成的表。即表尾一定是一个广义表。</p>
<p><strong>关键路径问题</strong></p>
<p>AOE网：用边来表示活动的网，是一个带权的有向无环图</p>
<p>AOE网可以解决下列问题：</p>
<ol>
<li>完成整个工程至少要多长时间</li>
<li>为缩短完成工程所需的时间，应当加快那些活动？</li>
</ol>
<p>从起点到终点的路径可能不止一条，只有各条路经上所有活动都完成了，整个工程才算完成</p>
<p>因此，完成整个过程所需的最短时间取决于从起点到终点的所有路径中，具有最长路径长度的那条路径，即这条</p>
<p>路径上所有活动的持续时间之和，在所在路径中最大，这条路径长度最长的路径就叫做关键路径。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yankuncui/pictures/img/5FC736299FA44EC67A1BD343D3DD1617.jpg" alt="img"></p>
<p>事件的最早开始时间计算方法：</p>
<p>事件最早开始时间利用正推，找最长的路线,例如v2最早发生时间为3，v4选择最长的路线就是2+4那一条路线，v6就是2+4+2那一条线</p>
<p>事件的最迟开始时间计算方法：</p>
<p>从终点开始反推，用最终结果减去权值，选取结果最小的那个。例如v5就是8-1那一条线，v3就选8-4-2那条线</p>
<p>起点与终点不用计算，起点为0。</p>
<p>活动的最早开始时间，看路径的出发点利用公式计算</p>
<p>例如算a5，先看它的起始点(a5的入度点)是v3，所以e=ve(v3)=2,然后在看它的终止点(a5的出度点)是v4,vl(k)=vl(v4)=6,dut=4,然后利用公式l=6-4=2,求出结果。同理，l2=2-2=0;l3=6-2=4;l4=7-3=4;l5=6-4=2;l6=8-3=5;l7=8-2=6;l8=8-1=7;e就是对应初始点的最早事件时间。</p>
<p><strong>拓扑排序</strong></p>
<p>AOV-网：用顶点表示活动，用弧表示活动间的优先关系的有向关系图，称为顶点表示活动的网，简称AOV-网</p>
<p>设G=(V,E)是一个具有n个顶点的有向图，V中顶点序列v1,v2,v3,v4—-vn称为一个拓扑序列，当且仅当该顶点序列满足下列条件</p>
<p>若&lt;i,j&gt;是图中的边(或从顶点i-&gt;j有一条路径):</p>
<p>则在拓扑序列中顶点i必须排在顶点 j之前。</p>
<p>在一个有向图中找一个拓扑序列的过程称为拓扑排序。</p>
<p>求拓扑排序的基本思想：</p>
<ol>
<li>从有向图中选一个无前驱(入度为0)的顶点输出；</li>
<li>将此顶点和以它为起点的弧删除；</li>
<li>重复1和2，直到不存在无前驱的顶点；</li>
<li>若此时输出的顶点数小于有向图中的顶点数，则说明有向图中存在回路，否则输出的顶点的顺序即为一个拓扑序列。</li>
</ol>
<p>拓扑排序的算法步骤：</p>
<ol>
<li><p>求所有顶点的入度，可以附设一个存放各个顶点入读的数组 indegree[]</p>
</li>
<li><p> 求所有顶点入度为0的顶点入队列或栈</p>
</li>
<li><p>当栈和队列不为空时</p>
<ul>
<li>出栈或出队列顶点为u，输出顶点u</li>
<li>顶点u的所有邻接点入度减一，如果有入度为0的顶点，则入栈或入队列</li>
</ul>
<p>4.若此时输出的顶点数小于有向图的顶点数，则说明有向图中存在回路，否则输出的顶点地顺序即为一个拓扑序列。</p>
</li>
</ol>
<p>具体实例：</p>
<p><img src="https://cdn.jsdelivr.net/gh/yankuncui/pictures/img/78C91C6EB4A12F311ED3157B18BC1873.jpg" alt="img"></p>
<p>根据上图还可以得出其它拓扑序列，如v6,v1,v4,v3,v5,v2等等。</p>
<p><strong>将中缀表达式转为后缀表达式</strong></p>
<p>中缀表达式a + b*c + (d * e + f) * g，其转换成后缀表达式则为a b c * + d e * f + g * +。</p>
<p>转换过程需要用到栈，具体过程如下：</p>
<p>1）如果遇到操作数，我们就直接将其输出。</p>
<p>2）如果遇到操作符，则我们将其放入到栈中，遇到左括号时我们也将其放入栈中。</p>
<p>3）如果遇到一个右括号，则将栈元素弹出，将弹出的操作符输出直到遇到左括号为止。注意，左括号只弹出并不输出。</p>
<p>4）如果遇到任何其他的操作符，如（“+”， “*”，“（”）等，从栈中弹出元素直到遇到发现更低优先级的元素(或者栈为空)为止。弹出完这些元素后，才将遇到的操作符压入到栈中。有一点需要注意，只有在遇到” ) “的情况下我们才弹出” ( “，其他情况我们都不会弹出” ( “。</p>
<p>5）如果我们读到了输入的末尾，则将栈中所有元素依次弹出。</p>
<p><strong>中缀表达式转为后缀表达式转换地另一种简单粗暴方式</strong></p>
<p>1)先按照运算符的优先级对中缀表达式加括号，变成( ( a+(b<em>c) ) + ( ((d</em>e)+f) *g ) )</p>
<p>2)将运算符移到括号的后面，变成((a(bc)*)+(((de)<em>f)+g)</em>)+</p>
<p>3)去掉括号，得到abc*+de<em>f+g</em>+</p>
<p>具体实例1：</p>
<p>规则很多，还是用实例比较容易说清楚整个过程。以上面的转换为例，输入为a + b * c + (d * e + f)*g，处理过程如下：</p>
<p>1）首先读到a，直接输出。</p>
<p>2）读到“+”，将其放入到栈中。</p>
<p>3）读到b，直接输出。</p>
<p>此时栈和输出的情况如下：</p>
<p>4）读到“*”，因为栈顶元素”+”优先级比” * “ 低，所以将” * “直接压入栈中。</p>
<p>5）读到c，直接输出。</p>
<p>此时栈和输出情况如下：</p>
<p>6）读到” + “，因为栈顶元素” * “的优先级比它高，所以弹出” * “并输出， 同理，栈中下一个元素” + “优先级与读到的操作符” + “一样，所以也要弹出并输出。然后再将读到的” + “压入栈中。</p>
<p>此时栈和输出情况如下：</p>
<p>7）下一个读到的为”(“，它优先级最高，所以直接放入到栈中。</p>
<p>8）读到d，将其直接输出。</p>
<p>此时栈和输出情况如下：</p>
<p>9）读到” * “，由于只有遇到” ) “的时候左括号”(“才会弹出，所以” * “直接压入栈中。</p>
<p>10）读到e，直接输出。</p>
<p>此时栈和输出情况如下：</p>
<p>11）读到” + “，弹出” * “并输出，然后将”+”压入栈中。</p>
<p>12）读到f，直接输出。</p>
<p>此时栈和输出情况：</p>
<p>13）接下来读到“）”，则直接将栈中元素弹出并输出直到遇到”(“为止。这里右括号前只有一个操作符”+”被弹出并输出。</p>
<p>14）读到” * “，压入栈中。读到g，直接输出。</p>
<p>15）此时输入数据已经读到末尾，栈中还有两个操作符“*”和” + “，直接弹出并输出。</p>
<p>具体实例2</p>
<p>中缀表达式 a+b*(c-d)-e/f</p>
<p>加括号((a+(b*(c-d)))-e/f)</p>
<p>对应转化地后缀表达式 abcd- *+ef/-</p>
<p>具体实例3</p>
<p>中缀表达式 A+B*(C-D)-E/F</p>
<p>加括号((A+(B*(C-D)))-E/F)</p>
<p>对应转化的后缀表达式 ABCD- *+EF/-</p>
<p><strong>根据中缀表达式构建二叉树</strong><br>基于上面计算中缀表达式值的步骤，在遍历到操作数时建立新节点并将该节点压入操作数栈中。当操作符从操作符栈中出栈时为该操作符新建一个节点，并从操作数栈中pop出两个操作数节点，将第一个操作数节点作为新节点的右节点，第二个个作为左节点，之后将这个新节点压入操作数栈中。当最后一个操作符出栈时，就构成了二叉树，且最后一个操作符节点为根节点。</p>
<p>例子</p>
<p><img src="https://cdn.jsdelivr.net/gh/yankuncui/pictures/img/pol.png" alt="pol"></p>
<p><strong>森林与二叉树的转换</strong></p>
<p>森林转换为二叉树</p>
<p>如果F={T1,T2,T3…Tm}是森林，则可按如下规则转换成一颗二叉树B=(root,LB,RB)</p>
<ol>
<li>若F为空，即m=0，则B为空树。</li>
<li>若F非空，则m不等于0，即B的根root即为森林中第一颗树的根ROOT(T1)；B的左子树LB是从T1中根结点的子树森林F1={T11,T12….T1m}转换而成的二叉树，B的右子树RB是从T1中根结点的子树森林F11={T2,T3….Tm}转换而成的二叉树。</li>
</ol>
<p>二叉树转换为森林</p>
<p>如果B=(root,LB,RB)是一颗二叉树，则可按如下规则转换成森林F={T1,T2,T3…Tm}：</p>
<ol>
<li>若B为空，则F为空</li>
<li>若B非空，则F中第一棵树T1的根ROOT(T1)即为二叉树B的根root；T1中根结点的子树森林F1是由B的左子树LB转换而成的森林；F中除T1之外其余树组成的森林F11={T2,T3…Tm}是由B的右子树RB转换而成的森林。</li>
</ol>
<p>注：上述算法均可采用递归实现。</p>
<p><strong>查找</strong></p>
<p>折半查找(条件是元素必须排好序且为顺序存储)</p>
<p>利用递归算法</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*折半查找递归函数，如果查找成功，函数返回关键字所在位置，否则返回-1*&#x2F;</span><br><span class="line">&#x2F;* s为有序数列，a、b分别为查找区间的起点和终点，key为查找关键字 *&#x2F;</span><br><span class="line">int half(int s[],int a,int b,int key)</span><br><span class="line">&#123;</span><br><span class="line">int mid;</span><br><span class="line">if(a&#x3D;&#x3D;b)</span><br><span class="line">if(key&#x3D;&#x3D;s[a]) return (a);</span><br><span class="line">else return (-1);</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">mid&#x3D;(a+b)&#x2F;2;</span><br><span class="line">if(key&lt;s[mid]) return(half(s,a,mid,key));</span><br><span class="line">if(key&gt;s[mid]) return(half(s,mid+1,b,key));</span><br><span class="line">if(key&#x3D;&#x3D;s[mid]) return (mid);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>不使用递归算法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int bSearch(int data[], const int x)</span><br><span class="line">&#123;</span><br><span class="line">    int mid,low&#x3D;1,high&#x3D;data.lenth;</span><br><span class="line">   </span><br><span class="line">    while(low &lt;&#x3D; high)</span><br><span class="line">    &#123;</span><br><span class="line">        mid &#x3D; (low + high) &#x2F; 2;</span><br><span class="line">        if (x &#x3D;&#x3D; data[mid] )</span><br><span class="line">        &#123;</span><br><span class="line">            return mid;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (data[mid] &lt; x)</span><br><span class="line">        &#123;</span><br><span class="line">            low &#x3D; mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (data[mid] &gt; x)</span><br><span class="line">        &#123;</span><br><span class="line">            high &#x3D; mid - 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>顺序查找</p>
<p>就是一个一个找</p>
<p>归并排序</p>
<p>算法步骤：</p>
<p>2-路归并排序将R[low…high]中的记录归并排序后放入到T[low…high]中。当序列长度等于1时，递归结束，否则：</p>
<ol>
<li>将当前序列一分为二，求出分裂点mid=(low+high)/2;</li>
<li>对子序列R[low…mid]递归，进行归并排序，结果放入S[low…mid]中；</li>
<li>对子序列R[mid+1…high]递归，进行归并排序，结果放入S[mid+1…high]中；</li>
<li>调用算法merge，将有序的两个子序列S[low…mid]和S[mid+1…high]归并为一个有序的序列T[low…high]。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">merge归并算法</span><br><span class="line">  void merge(RedType R[],RedType T[],int low ,int mid ,int high)</span><br><span class="line">&#123;&#x2F;&#x2F;将两个有序表合并</span><br><span class="line">  i&#x3D;low;</span><br><span class="line">  j&#x3D;mid+1;</span><br><span class="line">  k&#x3D;low;</span><br><span class="line">  while(i&lt;&#x3D;mid&amp;&amp;j&lt;&#x3D;high)  &#x2F;&#x2F;将R中记录由小到大地并入T中</span><br><span class="line">  &#123;</span><br><span class="line">    if(R[i].key&lt;&#x3D;R[j].key) T[k++]&#x3D;R[k++];</span><br><span class="line">    else T[k++]&#x3D;R[k++];</span><br><span class="line">  &#125;</span><br><span class="line">  while(i&lt;&#x3D;mid) T[k++]&#x3D;R[i++];   &#x2F;&#x2F;将剩余地R[i...mid]复制到T中</span><br><span class="line">  while(j&lt;&#x3D;high) T[k++]&#x3D;R[j++];  &#x2F;&#x2F;将剩余地R[j...high]复制到T中</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void msort(RedType R[],RedType T[],int low ,int high)</span><br><span class="line">&#123;&#x2F;&#x2F;R[low...high]归并排序后放入T[low...high]中</span><br><span class="line">  if(low&#x3D;&#x3D;high)</span><br><span class="line">  T[low]&#x3D;R[low];</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">  mid&#x3D;(low+high)&#x2F;2;  &#x2F;&#x2F;将当前序列一分为二，求出分裂点mid</span><br><span class="line">  msort(R,S,low,mid); &#x2F;&#x2F;对子序列R[low...mid]递归归并排序，结果放入S[low...mid]</span><br><span class="line">  msort(R,S,mid+1,high); &#x2F;&#x2F;对子序列R[mid+1...high]递归归并排序，结果放入S[mid+1...high]</span><br><span class="line">  merge(S,T,low,mid,high);&#x2F;&#x2F;将S[low...mid]和S[mid+1...high]归并到T[low...high]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">void mergesort(SqList &amp;L)</span><br><span class="line">&#123;&#x2F;&#x2F;对顺序表L做归并排序</span><br><span class="line">  msort(L.r,L.r,1,L.lenth);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>1、某科研单位的研究员信息可采用带头结点的单链表存储。简便起见，只存储病人姓名。结点结构如下：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><img src="https://cdn.jsdelivr.net/gh/yankuncui/pictures/img/wps1.jpg" alt="img"></td>
</tr>
</tbody></table>
<p> (1)假设第i个研究员已经离职，请定义数据结构并设计算法，查找该研究员信息并删除，同时输出该信息，返回 1；查找失败时返回 0。</p>
<p> (2)请分析该算法的时间性能。</p>
<p>解：</p>
<p>(1)首先定义一个结构体，里面包含研究员的各项信息，并定义一个单链表的结构指针，里面包含结点的数据域data，结点的指针域next，然后进行查找，初始化一个指针p,p指向首元结点，顺序域向后扫描，利用 while循环并加入查找条件，p指向下一个结点，如果找到结果循环终止，如果查找成功，就返回1，并将结果记录下来并输出，如果查找失败，就返回0，删除根据查找的结果记录信息在结构体当中的位置，根据位置进行删除，找到位置后，临时保存被删减结点的地址以备释放，然后改变删除结点前驱结点的指针域并释放删除结点的空间。</p>
<p>(2)经分析得，该算法涉及到了查找与删除，根据它们基本语句的执行次数，可得时间复杂度均为O(n)</p>
<p>2、计算机在求解算术表达式的值时，需要先将中缀表达式转换为后缀表达式，然后再求解。现有中缀表达式2+(5*7-9)/2，请完成下列任务：</p>
<p>(1) 一个算术表达式可以用二叉树来表示，利用二叉树的遍历很容易实现表达式的求值。试针对题目给定的算术表达式画出相应的*表达式树</p>
<p>(2)请说明如何利用表达式树将中缀表达式转换为后缀表达式，并给出后缀表达式序列。</p>
<p>(3)在计算后缀表达式时，需要设置一个栈 **S，用于存放操作数和中间运算结果。具体运算思想如下：依次读入后缀表达式中的字符（一个整数看成是一个字符，如21 作为一个字符处理）并判断，如果是操作数，则将操作数进入栈 S；如果是运算符，则将操作数出栈两次，然后对出栈的两个操作数利用当前操作符进行运算，直到整个表达式处理完毕，栈顶元素值就是所求算术表达式的值。</p>
<p> 请根据第 2 小题中求得的后缀表达式，按下表的格式写出求解后缀表达式的过程和最终结果，表中栈 S 的左端看作栈底。</p>
<p>3、在 DNA 序列中查询基因编码、查询文本中关键字信息时等经常需要通过字符串匹配进行信息检索，最常用的匹配算法有 BF 算法和 KMP 算法。</p>
<p>(1)、 [简答题]</p>
<p>试根据 BF 算法思想画出主串 abcdabcabadcbafg 与模式串 abaabacaba 前四趟匹配过程。</p>
<p>(2) 、 [简答题]</p>
<p>利用 KMP 算法，求模式串的 abaabacaba 的 next 函数值，完成下表。</p>
<p> 4、在军事、金融等领域信息传输过程中，上报和信息发布传输速度的非常重要。利用哈夫曼编码进行通信，可以压缩通信的数据量，提高传输效率，缩短信息的传输时间。假设需要传输的疫情信息仅由  8  个字母（A、B、C、D、E、F、G、H）组成，字母在疫情信息中出现的频度分别为 0.07，0.19，0.02， 0.06，0.32，0.03，0.21，0.10。</p>
<p>现采用哈夫曼编码传输信息。</p>
<p>(1)、 请给出对应哈夫曼树的构造过程。</p>
<p>(2)、请给出构造过程中存储结构的终结状态</p>
<p>(3)、请为这8 个字母设计哈夫曼编码</p>
<p>(4)、假设某次待传信息为ABBECDEFGH，求编码结果。</p>
<p>(5)、假设理想状态的信道传输，即数据从发送端到接收端是无差错的，请以这 8 个字母中码长最长的一个字母的编码为例，给出译码过程。</p>
<p>5、假设某省要为其辖区下的 6 个城市之间建立专用通信网络。经专家组考察和测评，得出部分城市间构建通信线路造价如下表所示。请就该工程总造价问题，进行数据对象的抽象、分析、建模。</p>
<p> <img src="https://cdn.jsdelivr.net/gh/yankuncui/pictures/img/image-20210609093433308.png" alt="image-20210609093433308"></p>
<p>(1)、[简答题]说明采用哪种数据结构较为合适，并画出数据结构图。</p>
<p>(2)、 [简答题]请画出上图的邻接表。<br>(3)、 [简答题]试画出自城市 1 出发进行遍历所得的广度优先生成树。</p>
<p>(4)、 [简答题]欲求工程总造价最低，可转化为求图的最小生成树问题，按照普里姆算法（加点法），给出从省会城市 6 出发构造最小生成树的过程。</p>
<p>6、自新冠病毒爆发以来，经过全国上下共同努力，我国疫情已经被成功控制，但目前仍有少数病例尚未治愈，部分地区的现有病例数见下表。分析使用其中数据，完成下列任务。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yankuncui/pictures/img/wps6.png" alt="img"></p>
<p>(1)、使用二分法查找任意地区的现有病例，要求：</p>
<ol>
<li><p>  给出算法基本设计思想；</p>
</li>
<li><p>  任选高级程序设计语言，给出数据类型定义；</p>
</li>
<li><p>  根据算法设计思想，用定义数据类型的高级语言描述算法；</p>
</li>
<li><p>  计算查找成功时的平均查找长度。</p>
</li>
</ol>
<p>(2)、使用散列表查找任意地区的现有病例数，散列地址空间为 0～10，散列函数为 H(key)=(key 的拼音首字母 ASCII 码)%11，使用线性探测再散列法解决冲突。统一使用大写字母，字母 A 的 ASCII 码为 65。要求：</p>
<ol>
<li><p>  构造散列表；</p>
</li>
<li><p>  计算散列因子；</p>
</li>
<li><p>  计算查找成功时的平均查找长度；</p>
</li>
<li><p>  使用线性探测再散列法解决冲突有什么缺点？可以换用什么方法？</p>
</li>
</ol>
<p>(3)、为了提高查找效率，可以先对表中数据进行排序，你了解的排序算法有哪些？分别适用于什么情况？稳定性如何？请至少说出两种算法。</p>
<p>(4)、如果要用希尔排序法对表中数据按照现有病例数进行非递减排序，请给出每趟排序的结果（增量序列为 5、3、1，以病例数代表数据记录参与排序）。</p>
<hr>
<p>2021年6月8日       星期二      晴</p>
<p>​                                                                                             <strong>JSP相关复习内容</strong></p>
<p>有序列表的实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ol type&#x3D;&quot;1&quot;&gt;</span><br><span class="line">&lt;li&gt;java&lt;&#x2F;li&gt;</span><br><span class="line">&lt;li&gt;jsp&lt;&#x2F;li&gt;</span><br><span class="line">&lt;li&gt;PHP&lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ol&gt;</span><br></pre></td></tr></table></figure>

<p>无序列表的实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ul type&#x3D;&quot;1&quot;&gt;</span><br><span class="line">&lt;li&gt;1&lt;&#x2F;li&gt;</span><br><span class="line">&lt;li&gt;2&lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br></pre></td></tr></table></figure>

<p>html页面结构标签</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;br&gt;换行的意思</span><br><span class="line">&lt;hr&gt;加入一条下划线</span><br><span class="line">&lt;p&gt;&lt;&#x2F;p&gt;段落标签</span><br><span class="line">&lt;font&gt;&lt;&#x2F;font&gt;文字格式标签，有 face,size,color等属性</span><br><span class="line">&lt;pre&gt;&lt;&#x2F;pre&gt;预定格式标签，可以将一首诗按照格式输出</span><br><span class="line">&lt;!--&gt;注释标签</span><br></pre></td></tr></table></figure>

<p>向页面中插入超链接</p>
<p>格式为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;资源地址&quot;  target&#x3D;&quot;目标窗口&quot;&gt;超链接名字&lt;&#x2F;a&gt;</span><br><span class="line">具体实例</span><br><span class="line">&lt;a href&#x3D;&quot;www.baidu.com&quot; target&#x3D;&quot;_blank&quot;&gt;百度以下&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>

<p>定义表格</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">   &lt;tr&gt;</span><br><span class="line">     &lt;th&gt;第一列标题的名字&lt;&#x2F;th&gt;</span><br><span class="line">     &lt;th&gt;第二列标题的名字&lt;&#x2F;th&gt;</span><br><span class="line">     &lt;th&gt;第三列标题的名字&lt;&#x2F;th&gt;</span><br><span class="line">   &lt;&#x2F;tr&gt;</span><br><span class="line">   &lt;tr&gt;</span><br><span class="line">     &lt;td&gt;第一行的第一个单元格&lt;&#x2F;td&gt;</span><br><span class="line">     &lt;td&gt;第一行的第二个单元格&lt;&#x2F;td&gt;</span><br><span class="line">     &lt;td&gt;第一行的第三个单元格&lt;&#x2F;td&gt;</span><br><span class="line">   &lt;&#x2F;tr&gt;  </span><br><span class="line">   &lt;tr&gt;</span><br><span class="line">     &lt;td&gt;第二行的第一个单元格&lt;&#x2F;td&gt;</span><br><span class="line">     &lt;td&gt;第二行的第二个单元格&lt;&#x2F;td&gt;</span><br><span class="line">     &lt;td&gt;第二行的第三个单元格&lt;&#x2F;td&gt;</span><br><span class="line">   &lt;&#x2F;tr&gt;  </span><br><span class="line">&lt;&#x2F;table&gt;   </span><br></pre></td></tr></table></figure>

<p>table的常用属性有border:设置表格边框的宽度，width与height分别表示宽度与高度，bgcolor表格背景色，bordercolor表格边框颜色</p>
<p>加入CSS的三种方式</p>
<p>嵌入式样式表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p style&#x3D;&quot;color:red;font-size:10pt&quot;&gt;使用嵌入式样式表&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure>

<p>内联式样式表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;htmL&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;内联式&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;meta http-equiv&#x3D;&quot;Content-Type&quot;content&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot;</span><br><span class="line">    &lt;style type&#x3D;&quot;text&#x2F;css&quot;</span><br><span class="line">    &lt;!--</span><br><span class="line">       p&#123;</span><br><span class="line">       font-family:宋体;</span><br><span class="line">       font-szie:9pt;</span><br><span class="line">       color:blue;</span><br><span class="line">       text-decoration:underline</span><br><span class="line">       &#125;</span><br><span class="line">       h2&#123;</span><br><span class="line">       font-family:宋体;</span><br><span class="line">       font-size:13pt;</span><br><span class="line">       color:red</span><br><span class="line">       &#125;</span><br><span class="line">      --&gt;</span><br><span class="line">      &lt;&#x2F;style&gt;</span><br><span class="line">      &lt;body&gt;</span><br><span class="line">      &lt;h2&gt;本标题字体大小13磅，字体颜色为红色&lt;&#x2F;h2&gt;</span><br><span class="line">      &lt;p&gt;本段文字大小为9磅，字体颜色为蓝色&lt;&#x2F;p&gt;</span><br><span class="line">      &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;      </span><br></pre></td></tr></table></figure>

<p>外联式样式表</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">StyleSheet.css文件</span><br><span class="line">p&#123;</span><br><span class="line">  background-color:yellow;</span><br><span class="line">  color:blue;</span><br><span class="line">  font-style:italic</span><br><span class="line">&#125;</span><br><span class="line">.text&#123;</span><br><span class="line">  font-family: 宋体;</span><br><span class="line">  font-size:20pt;</span><br><span class="line">  text-decoration:underline</span><br><span class="line">&#125;</span><br><span class="line">在网页上引入css文件</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line"> &lt;title&gt;外联式样式表&lt;&#x2F;title&gt;</span><br><span class="line"> &lt;meta http-equiv&#x3D;&quot;Content-type&quot; content&#x3D;&quot;text&#x2F;html&quot;;charset&#x3D;UTF-8&quot;&gt;</span><br><span class="line"> &lt;link href&#x3D;&quot;StyleSheet.css&quot; rel&#x3D;&quot;stylesheet&quot; type&#x3D;&quot;text&#x2F;css&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;h1 class&#x3D;&quot;text&quot;&gt;本标题文字大小20磅，有下划线&lt;&#x2F;h1&gt;</span><br><span class="line">  &lt;p&gt;本段文字背景颜色为黄色，字体颜色为蓝色，斜体&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<p>使用优先级顺序从高到底依次是嵌入式样式表、内联式样式表、外联式样式表、浏览器默认。</p>
<p>写登陆界面时需要在body标签下面加入一个动作用于跳转</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h2&gt;标题&lt;&#x2F;h2&gt;</span><br><span class="line">&lt;form action&#x3D;&quot;xxx.jsp&quot; method&#x3D;&quot;post&quot;</span><br><span class="line">此部分是设计的登陆界面，当点击登录时就会跳转至xxx.jsp</span><br><span class="line">&lt;&#x2F;form&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>

<p>page指令的属性</p>
<ol>
<li><p>lauguage属性，指定jsp使用的脚本语言</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如</span><br><span class="line">&lt;% @page lauguage&#x3D;&quot;java&quot; %&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>extends属性，指定jsp编译器父类的完整限定名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如</span><br><span class="line">&lt;% @page extends&#x3D;&quot;javax.servlet.http.HttpServlet&quot; %&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>import属性</p>
<p>import属性为JSP页面引入JAVA包中的类，可多次设置</p>
<p>4.session属性</p>
</li>
</ol>
<p>​       session属性用于指定是否可用session对象，若允许就设置为true,否则设为false,默认值为true。</p>
<p>JSP动作</p>
<ol>
<li><p>param</p>
<p>此动作可用于include,forward动作体中，为其他动作传送一个或多个参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法格式</span><br><span class="line">&lt;jsp:param name&#x3D;&quot;参数名&quot; value&#x3D;&quot;参数值&quot;&gt;</span><br><span class="line">name属性用于指定参数值名称，不可以接受动态值，value属性用于指定参数值名称，可以接受动态值</span><br></pre></td></tr></table></figure></li>
<li><p>include</p>
<p>此动作用来把指定文件动态插入正在生成的界面中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法格式</span><br><span class="line">&lt;jsp:include page&#x3D;&quot;文件名&quot; flush&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">或</span><br><span class="line">&lt;jsp:include page&#x3D;&quot;文件名&quot; flush&#x3D;&quot;true&quot;&gt;</span><br><span class="line"> &lt;jsp:param name&#x3D;&quot;参数&quot; value&#x3D;&quot;参数值&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;jsp:include&gt;</span><br><span class="line">具体实例</span><br><span class="line">&lt;jsp:include page&#x3D;&quot;hello.jsp&quot;&#x2F;&gt;</span><br><span class="line">上述语句便可以在本界面上运行其他界面的内容</span><br></pre></td></tr></table></figure></li>
<li><p>usebean</p>
<p>此动作用来加载在JSP页面中使用到的JavaBean,这个功能非常有用，可以实现JavaBean组件重用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法格式</span><br><span class="line">&lt;jsp:usebean id&#x3D;&quot;bean实例名称&quot; scope&#x3D;&quot;page | request |session |application&quot;</span><br><span class="line">  class&#x3D;&quot;JavaBean类&quot; type&#x3D;&quot;对象变量的属性&quot; beanName&#x3D;&quot;Bean名字&quot;</span><br><span class="line">  具体实例</span><br><span class="line">  &lt;jsp:usebean id&#x3D;&quot;time&quot; class&#x3D;&quot;java.util.Date&quot;&gt;</span><br><span class="line">  现在时间&lt;%&#x3D;time%&gt;</span><br></pre></td></tr></table></figure>

<p>各个作用域的范围</p>
<ul>
<li>page:表示该bean只能在当前页面内使用 (保存在当前页面的PageContext内)</li>
<li>request:表示该bean在当前的客户请求内有效(保存在ServletRequest对象内)</li>
<li>session:表示该bean对当前HttpSession内的所有页面都有效，即会话作用域内有效</li>
<li>application:表示该bean在任何使用相同的application的页面都有效，即整个应用程序范围内有效</li>
</ul>
</li>
<li><p>setProperty</p>
<p>此动作用来设置、修改已实例化Bean的属性值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法如下</span><br><span class="line">&lt;jsp:setProperty name&#x3D;&quot;Bean的名称&quot; property&#x3D;&quot;*&quot; |property&#x3D;&quot;属性&quot; [param&#x3D;&quot;属性&quot; |value&#x3D;&quot;值&quot;]</span><br><span class="line">*表示所有名字和Bean属性名字匹配的请求参数，都将被传递相应属性的set方法</span><br></pre></td></tr></table></figure></li>
<li><p>getProperty</p>
</li>
</ol>
<p>​      此动作用于获取指定bean属性值后转换为字符串输出</p>
<pre><code>  语法如下
  &lt;jsp:getProperty name=&quot;Bean的名称&quot; property=&quot;Bean的属性&quot;/&gt;
  可以获取Bean的属性值并使用或将其显示在jsp页面中，在使用&lt;jsp:getproperty&gt;之前，必须用&lt;jsp:useBean&gt;创建实例化对象
</code></pre>
<p>   6.forward</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">说明代码&lt;jsp:forward page&#x3D;&quot;b.jsp&quot;&gt;&lt;&#x2F;jsp:forward&gt; 起到了页面跳转的作用</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>表达式用法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;%!</span><br><span class="line">String name&#x3D;&quot;666&quot;;</span><br><span class="line">%&gt;</span><br><span class="line">用户名&lt;%&#x3D;name%&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">实例中&lt;%&#x3D;name%&gt;用于获取属性值</span><br><span class="line">变量声明&lt;!% int x;%&gt;注意必须啊以分号结尾感叹号可以省略</span><br><span class="line">具体实例</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;%!</span><br><span class="line"> String str&#x3D;&quot;666&quot;;</span><br><span class="line"> %&gt;</span><br><span class="line">&lt;%!</span><br><span class="line"> String print()&#123;</span><br><span class="line">  return str;</span><br><span class="line"> &#125;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;%&#x3D;print()%&gt;&#x2F;&#x2F;调用函数</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>

<p>三种注释</p>
<ol>
<li><p>隐藏注释</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 注释语句--&gt;</span><br><span class="line">这种注释在发布网页时不会被看到，但在客户端源文件可以看到</span><br></pre></td></tr></table></figure></li>
<li><p>java注释</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法格式</span><br><span class="line">&lt;%&#x2F;*注释语句*&#x2F;%&gt;或者&lt;%&#x2F;&#x2F;注释语句%&gt;</span><br><span class="line">这种注释在发布网页时不会被看到，在客户端源文件也看不到</span><br></pre></td></tr></table></figure></li>
<li><p>html注释</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 注释语句[&lt;%&#x3D;表达式%&gt;]--&gt;</span><br><span class="line">实例</span><br><span class="line">&lt;!--这一行注释在发布网页时不会被看到，但在客户端源文件可以看到&lt;%&#x3D;new java.util.Date()%&gt;--&gt;</span><br><span class="line">这种注释在发布网页时不会被看到，但在客户端源文件可以看到</span><br></pre></td></tr></table></figure></li>
</ol>
<p>out对象</p>
<p>out对象可以调用一些方法将数据输出到网页上，如print() 、println()等</p>
<p>具体实例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;%</span><br><span class="line"> for(int i&#x3D;0;i&lt;3;i++)</span><br><span class="line">   out.println(&quot;&lt;h3&gt;我的理想&lt;&#x2F;h3&gt;&quot;);</span><br><span class="line">   String str&#x3D;&quot;123456&quot;;</span><br><span class="line">   out.print(&quot;str+&lt;br&gt;&quot;);</span><br><span class="line">   out.println(&quot;加油&quot;);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>

<p>out对象于system.out的区别</p>
<ol>
<li><p>JSP的out是JSP的内置对象，用于在JSP页面中输出内容。</p>
<p>2.system.out用于在java程序中，输出内容，本地输出。</p>
<p>3.一个是本地（java类所在环境）输出内容，一个是JSP页面（可以在N多请求此页面的地方）内容输出。</p>
</li>
</ol>
<p>session对象</p>
<p>session对象用于存储特定的用户会话所需的信息，当用户在应用程序的web页面之间跳转时，存储在session对象的变量将不会丢失，而是整个用户会话一直存在，session的生命周期是当用户请求来自应用程序的web页面时，如果该用户没有会话，则web服务器将自动创建一个session对象，当会话过期或被放弃后，服务器将终止该会话。</p>
<p>application对象</p>
<p>application对象是用来保存 java web应用程序的变量，并且所有用户不论何时皆可存取使用 ，application对象的最大特点是没有生命周期，无论浏览器是否被关闭，application对象都存在于主机上。</p>
<p>编写javaBean组件</p>
<p>先写一个java类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@lombok</span><br><span class="line">public login&#123;</span><br><span class="line">private String userName;</span><br><span class="line">private String password;</span><br><span class="line">&#125;</span><br><span class="line">利用useBean引入</span><br><span class="line">&lt;jsp:useBean id&#x3D;&quot;login&quot; class&#x3D;&quot;包名.login&quot;&#x2F;&gt;</span><br><span class="line">设置属性值实例</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;jsp:useBean id&#x3D;&quot;login&quot; class&#x3D;&quot;包名.login&quot;&#x2F;&gt;</span><br><span class="line">&lt;jsp:setProperty name&#x3D;&quot;login&quot; property&#x3D;&quot;userName&quot; value&#x3D;&quot;10001&quot;&#x2F;&gt;</span><br><span class="line">&lt;jsp:setProperty name&#x3D;&quot;login&quot; property&#x3D;&quot;password&quot; value&#x3D;&quot;123456789&quot;&#x2F;&gt;</span><br><span class="line">&lt;hr&gt;</span><br><span class="line">用户名:&lt;jsp:getProperty name&#x3D;&quot;login&quot; property&#x3D;&quot;useName&quot;&#x2F;&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">密码是:&lt;jsp:getProperty name&#x3D;&quot;login&quot; property&#x3D;&quot;password&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> Servlet中的doPost()方法于doGet()方法的编写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Verify extends HttpServlet&#123;</span><br><span class="line">     public void doPost(HttpServletRequest request,HttpServletResponse response)</span><br><span class="line">      throws ServletException,IOException&#123;</span><br><span class="line">      String number&#x3D;request.getParameter(&quot;number&quot;);</span><br><span class="line">      try&#123;</span><br><span class="line">       double n&#x3D;Double.parseDouble(number);</span><br><span class="line">       if(n&gt;6000||n&lt;-6000)</span><br><span class="line">       &#x2F;&#x2F;重定向至sendforward.jsp</span><br><span class="line">        response.sendRedirect(&quot;sendforward.jsp&quot;);</span><br><span class="line">        else&#123;</span><br><span class="line">        &#x2F;&#x2F;实现请求转发</span><br><span class="line">        RequestDispatcher dispatcher&#x3D;request.getRequestDispatcher(&quot;showmessage&quot;);</span><br><span class="line">           dispacher.forward(request,response);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      catch(NumberFormatException e)&#123;</span><br><span class="line">      &#x2F;&#x2F;重定向至sendforward.jsp</span><br><span class="line">            response.sendRedirect(&quot;sendforward.jsp&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   public void doGet(HttpServletRequest request,HttpServletResponse response)</span><br><span class="line">   throws ServletException,IOException&#123;</span><br><span class="line">        doPost(request,response);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Servlet的配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法格式</span><br><span class="line">&lt;servlet&gt;</span><br><span class="line">   &lt;servlet-name&gt;名字&lt;&#x2F;servlet-name&gt;</span><br><span class="line">   &lt;servlet-class&gt;包名.名字&lt;&#x2F;servlet-class&gt;</span><br><span class="line">&lt;&#x2F;servlet&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">   &lt;servlet-name&gt;名字&lt;&#x2F;servlet-name&gt;</span><br><span class="line">   &lt;url-pattern&gt;&#x2F;名字&lt;&#x2F;url-pattern&gt;</span><br><span class="line">&lt;servlrt-mapping&gt;</span><br><span class="line">&lt;session-config&gt;</span><br><span class="line">  &lt;session-timeout&gt;</span><br><span class="line">      30</span><br><span class="line">  &lt;&#x2F;session-timeout&gt;    </span><br><span class="line">具体实例的类</span><br><span class="line">&lt;servlet&gt;</span><br><span class="line">   &lt;servlet-name&gt;Verify&lt;&#x2F;servlet-name&gt;</span><br><span class="line">   &lt;servlet-class&gt;ch.Verify&lt;&#x2F;servlet-class&gt;</span><br><span class="line">&lt;&#x2F;servlet&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">   &lt;servlet-name&gt;Verify&lt;&#x2F;servlet-name&gt;</span><br><span class="line">   &lt;url-pattern&gt;&#x2F;Verify&lt;&#x2F;url-pattern&gt;</span><br><span class="line">&lt;servlrt-mapping&gt;</span><br></pre></td></tr></table></figure>

<p><strong>session与application的区别</strong><br>一、服务的对象不一样</p>
<p>在同一个浏览器窗口中，无论向服务器发送多少请求，session 对象只有一个；当 application 对象没有被销毁的时候，所有用户都可以享用该 application 对象。</p>
<p>二、性质不一样</p>
<p>session是会话变量，只要同一个浏览器没有被关闭，session对象就会存在；application它类似于系统的全局变量。</p>
<p>三、使用的人不一样</p>
<p>一个浏览器只能创建一个 session 变量；所有浏览器用户都可以使用服务器上的 application 对象。</p>
<p>四、保存的内容不一样</p>
<p>session 对象可以存储或者读取客户的相关信息；application 对象可以用于保存所有程序中的公有数据。</p>
<p>五、变量的生命周期不一样</p>
<p>可以通过编写程序进行修改这个 session 的生命周期的时间；application 的生命周期是最长的。</p>
<p><strong>jdbc的作用</strong><br>JDBC（Java Data Base Connectivity,java数据库连接）是一种用于执行SQL语句的Java API，可以为多种关系数据库提供统一访问，它由一组用Java语言编写的类和接口组成。JDBC提供了一种基准，据此可以构建更高级的工具和接口，使数据库开发人员能够编写数据库应用程序。<br>JDBC 可做三件事：与数据库建立连接、发送 SQL 语句并处理结果</p>
<p><strong>executeQuery()与executeUpdate()方法的作用及区别</strong></p>
<p>方法executeQuery<br>用于产生单个结果集（ResultSet）的语句，例如:被执行最多的SELECT 语句。<br>这个方法被用来执行 SELECT 语句，但也只能执行查询语句，执行后返回代表查询结果的ResultSet对象。<br>方法executeUpdate<br>用于执行 INSERT、UPDATE 或 DELETE 语句以及 SQL DDL（数据定义语言）语句，例如 CREATE TABLE 和 DROP TABLE。<br>INSERT、UPDATE 或 DELETE 语句的效果是修改表中零行或多行中的一列或多列。<br>executeUpdate 的返回值是一个整数（int），指示受影响的行数（即更新计数）。<br>对于 CREATE TABLE 或 DROP TABLE 等不操作行的语句，executeUpdate 的返回值总为零。<br>executeQuery的返回值为单个结果集，executeUpdate返回值是一个整数</p>
<p><strong>session的生命周期及其作用</strong></p>
<p>session的生命周期简单理解就是从用户打开浏览器访问你的servlet开始直到用户关闭了浏览器结束。<br>session的作用是用于保存每个用户的专用信息；当用户访问时，服务器都会为每个用户分配唯一的Session ID，而且当访问其他程序时可以从用户的session中取出该用户的数据为用户服务。</p>
<p>page指令的属性中可以多次设计的属性是import，import属性为JSP页面引入JAVA包中的类。</p>
<hr>
<p>2021年 6月9日  星期三  晴</p>
<p><strong>马原复习</strong></p>
<p> 1、马克思主义包括由马、恩创立和列宁等发展了的马克思主义，也包括中国共产党人将其与中国具体实际相结合，不断推进马克思主义中国化的理论成果。（马克思主义永葆青春的原因） 2、马克思主义三大来源：19世纪西欧三大先进思潮 德国古典哲学、英国古典政治经济学、英法两国的空想社会主义 3、唯物史观和剩余价值学说是马克思一生的两个伟大发现 4、习主席提出新形势下党治国理政的四个全面：全面建成小康社会、全面深化改革、全面依法治国、全面从严治党。 5、马克思主义具有强大生命力的根源：以实践为基础的科学性与革命性的统一。 6、全部哲学，特别是近代哲学的重大的基本问题，是思维和存在的关系问题。 7、存在和思维关系问题的两个方面：  一、存在和思维，究竟谁是世界的本源，即物质和精神何者是第一性、何者是第二性的问题。这一问题是划分唯物主义和唯心主义的标准。  二、我们关于我们周围世界的思想对这个世界本身的关系是怎么样的、我们的思维能不能认识现实世界、我们能不能在我们关于现实世界的表象和概念中正确地反映现实。这一问题是划分可知论和不可知论的标准。 8、马克思主义全称：辩证唯物主义和历史唯物主义 9、三阶段：古代朴素唯物主义、近代形而上学唯物主义、马克思主义哲学 10、运动与静止：物质世界的运动是绝对的，静止是相对的。相对静止是物质运动在一定条件下的稳定状态，包括空间的相对位置和事物的根本属性暂时未变这样两种运动的特殊状态。运动的绝对性体现了物质运动的变动性、无条件性，静止的相对性体现了物质运动的稳定性、有条件性。运动和静止相互依赖、相互渗透、相互包含，动中有静、静中有动。无条件的绝对运动和有条件的相对静止构成了对立统一的关系。 11、实践是自然存在与社会存在区分和统一的基础 12、从实践出发理解社会生活的本质：实践是使物质世界分化为自然界与人类社会的历史前提，又是使自然界与人类社会统一起来的现实基础。 13、从意识的本质看，意识是特殊的物质–人脑的机能和属性，是客观世界的主观映象，意识在内容上是客观的，在形式上是主观的，是客观内容和主观形式的统一。  14人类社会是否具有物质性，是在马克思主义之前没得到正确解决的问题。之前的旧唯物主义是“半截子”唯物主义，在自然观上是唯物主义，但一到社会历史领域就陷入了唯心主义15联系的特点：客观性、普遍性、多样性、条件性。16发展是前进的、上升的运动，发展的实质是新事物的产生和旧事物的灭亡。17规律就是事物联系和发展过程中所固有的本质的、必然的、稳定的联系。18三大规律：对立统一规律、质量互变规律、否定之否定规律19 对立统一规律之所以是唯物辩证法体系的实质和核心原因：对立统一规律揭示了事物普遍联系的根本内容和永恒发展的内在动力，从根本上回答了事物为什么会发展的问题。20矛盾的同一性和矛盾的斗争性在事物发展中具有重要作用。</p>
<hr>
<p>常考选择题</p>
<ol>
<li>哲学是理论化、系统化的世界观。</li>
<li>哲学的两大阵营指的是唯物主义和唯心主义</li>
<li>把可直接感知的某种具体实物看作是世界的本原，此观点属于朴素唯物主义。</li>
<li>形而上学唯物主义物质观的错误是不懂得个性与共性的辩证关系。</li>
<li>二元论的根本错误是否认世界的统一性。</li>
<li>在对现存事物的肯定的理解中同时包括这对现存事物的否定的理解，即对现存事物的必然灭亡的理解，这是一种唯物辩证法的观点。</li>
<li>矛盾的基本属性是斗争性和同一性。</li>
<li>下列说法中，说明要坚持两点论，全面地看问题的是兼听则明，偏信则暗。</li>
<li>揭示事物发展是前进性和曲折性统一的规律是否定之否定规律。</li>
<li>正确发挥意识能动作用的最基本前提是对客观规律的正确反映。</li>
<li>存在即是过程是唯物辩证法的观点。</li>
<li>真象与假象的区别在于真象是从正面直接地表现本质，假象是从反面歪曲地表现本质。</li>
<li>在现实中还没有充分的根据，也不具备必要的条件，在目前不能实现的可能性为抽象的可能性。</li>
<li>中国宋代哲学家朱熹提出理在事先，这种观点属于客观唯心主义。</li>
<li>价值原则是体现主体尺度的要求。</li>
<li>事物的发展既是连续的又是非连续的，这是辩证法的观点。</li>
<li>在经济基础中具有决定意义的是生产资料所有制关系。</li>
<li>非上层建筑的社会意识形式包括自然科学、语言学和逻辑学。</li>
<li>对马克思主义既要坚持，又要发展。这种正确态度的理论基础是真理是绝对性和相对性统一的原理。</li>
<li>在一定条件下，偶然性可能转化为必然性是唯物辩证法的观点。</li>
<li>否定之否定仿佛是向出发点的复归，这种观点是辩证法观点。</li>
<li>社会一旦有技术上的需要，则这种需要会比十所大学更能把科学推向前进，这表明实践的需要是推动认识发展的动力。</li>
<li>反映生产力发展水平的主要标志是生产工具的水平。</li>
<li>理解全部人类历史的钥匙，应当从生产劳动发展史中去寻找。</li>
<li>有人认为，地球上产生生命是纯粹偶然的，没有任何必然性，就像一个人偶然得到一笔巨款成为百万富翁一样。从哲学上看这是一种非决定论观点。</li>
<li>社会生活本质上是实践的观点属于唯物史观。</li>
<li>两条根本对立的认识路线是唯物主义反映论和唯心主义先验。</li>
<li>历史唯物主义认为，决定人的本质的是人的社会属性。</li>
<li>矛盾斗争的无条件是指能打破特定条件的限制。</li>
<li>一个完整的认识过程是感觉—知觉—表象。</li>
<li>直接经验和间接经验的关系是认识的源与流的关系。</li>
<li>在价值关系中要求物趋近人的观点体现了价值的主体性。</li>
<li>马克思根据人的发展状况把人类历史划分为依次更替的三大社会形态。这三大社会形态是：人的依赖性社会、物的依赖性社会、个人全面发展的社会。</li>
<li>人在价值关系中与其他存在物的最根本区别在于人既可以是价值客体又可以是价值主体，其他存在物只能是价值客体。</li>
<li>辩证法发展过程中经历的三种历史形态是：朴素辩证法、唯心辩证法、唯物辩证法。</li>
<li>物质的唯一特性是客观实在性，这里所说的客观实在是指不以人的意志为转移。</li>
<li>质和事物的存在是直接同一的。</li>
<li>认识是对主体的反映，这是一切唯物主义都承认的观点。</li>
</ol>
</div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">livere</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/tx.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">cuiyankun</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">35</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yankuncui/yankuncui.github.io.git"><i class="fab fa-github"></i><span>YanKun's Blog</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/04/09/JSON%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="JSON学习笔记"><img src="https://upimage.alexhchu.com/2020/10/21/5fecb0b094b73.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JSON学习笔记"/></a><div class="content"><a class="title" href="/2023/04/09/JSON%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="JSON学习笔记">JSON学习笔记</a><time datetime="2023-04-09T07:49:35.000Z" title="发表于 2023-04-09 15:49:35">2023-04-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/02/Resource%E7%9B%AE%E5%BD%95%E4%B8%8B%E5%B8%B8%E8%A7%81%E9%85%8D%E7%BD%AE/" title="Resource目录下常见配置文件"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Resource目录下常见配置文件"/></a><div class="content"><a class="title" href="/2023/04/02/Resource%E7%9B%AE%E5%BD%95%E4%B8%8B%E5%B8%B8%E8%A7%81%E9%85%8D%E7%BD%AE/" title="Resource目录下常见配置文件">Resource目录下常见配置文件</a><time datetime="2023-04-02T08:08:40.000Z" title="发表于 2023-04-02 16:08:40">2023-04-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/26/SpringBoot%E6%B3%A8%E8%A7%A3/" title="SpringBoot注解"><img src="https://upimage.alexhchu.com/2020/10/21/f5ac68ddaaf64.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SpringBoot注解"/></a><div class="content"><a class="title" href="/2023/03/26/SpringBoot%E6%B3%A8%E8%A7%A3/" title="SpringBoot注解">SpringBoot注解</a><time datetime="2023-03-26T08:08:40.000Z" title="发表于 2023-03-26 16:08:40">2023-03-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/27/IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%88%86%E7%89%87/" title="IP数据报分片"><img src="https://upimage.alexhchu.com/2020/10/21/5fecb0b094b73.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="IP数据报分片"/></a><div class="content"><a class="title" href="/2021/11/27/IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%88%86%E7%89%87/" title="IP数据报分片">IP数据报分片</a><time datetime="2021-11-27T01:47:56.000Z" title="发表于 2021-11-27 09:47:56">2021-11-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/27/%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86%E9%97%AE%E9%A2%98/" title="子网划分问题"><img src="https://upimage.alexhchu.com/2020/10/21/671e773d973ae.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="子网划分问题"/></a><div class="content"><a class="title" href="/2021/11/27/%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86%E9%97%AE%E9%A2%98/" title="子网划分问题">子网划分问题</a><time datetime="2021-11-27T01:17:14.000Z" title="发表于 2021-11-27 09:17:14">2021-11-27</time></div></div></div></div><div class="card-widget card-categories"><div class="item-headline">
            <i class="fas fa-folder-open"></i>
            <span>分类</span>
            <a class="card-more-btn" href="/categories/" title="查看更多">
    <i class="fas fa-angle-right"></i></a>
            </div>
            <ul class="card-category-list" id="aside-cat-list">
            <li class="card-category-list-item "><a class="card-category-list-link" href="/categories/JAVA/"><span class="card-category-list-name">JAVA</span><span class="card-category-list-count">11</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/JSP/"><span class="card-category-list-name">JSP</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/JavaScript/"><span class="card-category-list-name">JavaScript</span><span class="card-category-list-count">2</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/SpringBoot/"><span class="card-category-list-name">SpringBoot</span><span class="card-category-list-count">2</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/"><span class="card-category-list-name">前端</span><span class="card-category-list-count">2</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E6%8A%80%E6%9C%AF/"><span class="card-category-list-name">技术</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span class="card-category-list-name">数据结构</span><span class="card-category-list-count">6</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E7%AE%97%E6%B3%95/"><span class="card-category-list-name">算法</span><span class="card-category-list-count">5</span></a></li>
            </ul></div><div class="card-widget card-tags"><div class="item-headline"><i class="fas fa-tags"></i><span>标签</span></div><div class="card-tag-cloud"><a href="/tags/crud/" style="font-size: 1.2em; color: #999da3">crud</a> <a href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" style="font-size: 1.1em; color: #999">二叉树</a> <a href="/tags/%E4%BD%9C%E5%9B%BE/" style="font-size: 1.1em; color: #999">作图</a> <a href="/tags/%E5%81%B7%E6%87%92%E7%A5%9E%E5%99%A8/" style="font-size: 1.2em; color: #999da3">偷懒神器</a> <a href="/tags/%E5%90%8E%E7%AB%AF/" style="font-size: 1.1em; color: #999">后端</a> <a href="/tags/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/" style="font-size: 1.1em; color: #999">哈夫曼树</a> <a href="/tags/%E5%9B%BE%E5%BA%8A/" style="font-size: 1.1em; color: #999">图床</a> <a href="/tags/%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/" style="font-size: 1.1em; color: #999">常用函数</a> <a href="/tags/%E6%8E%92%E5%BA%8F/" style="font-size: 1.1em; color: #999">排序</a> <a href="/tags/%E6%9A%B4%E5%8A%9B%E5%8C%B9%E9%85%8D/" style="font-size: 1.1em; color: #999">暴力匹配</a> <a href="/tags/%E6%9E%9A%E4%B8%BE/" style="font-size: 1.1em; color: #999">枚举</a> <a href="/tags/%E6%A1%86%E6%9E%B6/" style="font-size: 1.5em; color: #99a9bf">框架</a> <a href="/tags/%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/" style="font-size: 1.1em; color: #999">模式匹配</a> <a href="/tags/%E6%B7%B1%E6%90%9C/" style="font-size: 1.1em; color: #999">深搜</a> <a href="/tags/%E7%AC%94%E8%AE%B0/" style="font-size: 1.1em; color: #999">笔记</a> <a href="/tags/%E7%AC%AC%E4%B8%80/" style="font-size: 1.1em; color: #999">第一</a> <a href="/tags/%E8%AE%A1%E7%AE%97/" style="font-size: 1.3em; color: #99a1ac">计算</a> <a href="/tags/%E8%AE%B0%E5%BF%86/" style="font-size: 1.4em; color: #99a5b6">记忆</a> <a href="/tags/%E8%B4%AA%E5%BF%83/" style="font-size: 1.1em; color: #999">贪心</a> <a href="/tags/%E9%81%8D%E5%8E%86/" style="font-size: 1.1em; color: #999">遍历</a></div></div><div class="card-widget card-archives"><div class="item-headline"><i class="fas fa-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/04/"><span class="card-archive-list-date">四月 2023</span><span class="card-archive-list-count">2</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/03/"><span class="card-archive-list-date">三月 2023</span><span class="card-archive-list-count">1</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/11/"><span class="card-archive-list-date">十一月 2021</span><span class="card-archive-list-count">4</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/09/"><span class="card-archive-list-date">九月 2021</span><span class="card-archive-list-count">4</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/06/"><span class="card-archive-list-date">六月 2021</span><span class="card-archive-list-count">6</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/05/"><span class="card-archive-list-date">五月 2021</span><span class="card-archive-list-count">8</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/04/"><span class="card-archive-list-date">四月 2021</span><span class="card-archive-list-count">10</span></a></li></ul></div><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>网站资讯</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">文章数目 :</div><div class="item-count">35</div></div><div class="webinfo-item"><div class="item-name">已运行时间 :</div><div class="item-count" id="runtimeshow" data-publishDate="2021-04-10T16:00:00.000Z"></div></div><div class="webinfo-item"><div class="item-name">本站访客数 :</div><div class="item-count" id="busuanzi_value_site_uv"></div></div><div class="webinfo-item"><div class="item-name">本站总访问量 :</div><div class="item-count" id="busuanzi_value_site_pv"></div></div><div class="webinfo-item"><div class="item-name">最后更新时间 :</div><div class="item-count" id="last-push-date" data-lastPushDate="2023-04-09T09:16:00.228Z"></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By cuiyankun</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'c99pOmUa6gV4G4GnPT9kzXs9-gzGzoHsz',
      appKey: 'Vwv6hPmgLRpyMvF5OpKF6tE6',
      placeholder: '请留下你的评论',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: true,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>