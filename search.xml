<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>广度遍历与深度遍历</title>
      <link href="2021/05/28/%E5%B9%BF%E5%BA%A6%E9%81%8D%E5%8E%86%E4%B8%8E%E6%B7%B1%E5%BA%A6%E9%81%8D%E5%8E%86/"/>
      <url>2021/05/28/%E5%B9%BF%E5%BA%A6%E9%81%8D%E5%8E%86%E4%B8%8E%E6%B7%B1%E5%BA%A6%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>哈夫曼树构造步骤及写出相应编码</title>
      <link href="2021/05/24/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E6%9E%84%E9%80%A0%E6%AD%A5%E9%AA%A4%E5%8F%8A%E5%86%99%E5%87%BA%E7%9B%B8%E5%BA%94%E7%BC%96%E7%A0%81/"/>
      <url>2021/05/24/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E6%9E%84%E9%80%A0%E6%AD%A5%E9%AA%A4%E5%8F%8A%E5%86%99%E5%87%BA%E7%9B%B8%E5%BA%94%E7%BC%96%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h1><p>给定N个权值作为N个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。</p><p>注：哈夫曼树并不唯一，带权路径长度一定相同。并且图的深度遍历序列不是唯一的。</p><h1 id="哈夫曼树的构造步骤"><a href="#哈夫曼树的构造步骤" class="headerlink" title="哈夫曼树的构造步骤"></a>哈夫曼树的构造步骤</h1><h2 id="由给定结点构造哈夫曼树"><a href="#由给定结点构造哈夫曼树" class="headerlink" title="由给定结点构造哈夫曼树"></a>由给定结点构造哈夫曼树</h2><p>(1)5个结点的权值大小如下：<br>1 2 3 4 5</p><p>(2)从1 2 3 4 5五个结点中选出两个权值最小的。选出1 2，同时算出这两个结点的权值之和3。</p><p>(3)继续从3 4 5 3四个结点选出两个权值最小的。选出3 3，同时算出这两个结点的权值之和6。</p><p>(4)继续从4 5 6三个结点选出两个权值最小的。选出4 5，这是选出的两个数不是构造好的树里面的结点，需要在旁边新建一个分叉，并计算这两个结点的和9。</p><p>注：如果选出的两个数字都不是已经构造好的二叉树里面的结点，所以要另外开一棵二叉树；或者说，如果两个数的和正好是下一步的两个最小数的其中的一个，那么这个树直接往上生长就可以了，如果这两个数的和比较大，不是下一步的两个最小数的其中一个，那么就并列生长。</p><p>(5)最后选出6 9两个结点合并成为哈夫曼树。</p><p>如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/yankuncui/pictures/img/20210524170030.png" alt="fms"></p><h2 id="根据哈夫曼树写出哈夫曼编码"><a href="#根据哈夫曼树写出哈夫曼编码" class="headerlink" title="根据哈夫曼树写出哈夫曼编码"></a>根据哈夫曼树写出哈夫曼编码</h2><p>根据构造的哈夫曼树</p><p><img src="https://cdn.jsdelivr.net/gh/yankuncui/pictures/img/20210524170339.jpg" alt="fmsm"></p><p>6： 0，3：00(左)，3：01(右)，9：1，4：10，5：11，1：000，2：001</p><h2 id="wpl的计算"><a href="#wpl的计算" class="headerlink" title="wpl的计算"></a>wpl的计算</h2><p>从根部开始，根为第0层，依次往下累加，将对应层数与权值相乘在累加的到结果。</p><p>wpl=1X3+2X3+3X2+4X2+5X2=33</p><p>在问题中，wpl有多种问法，例如求哈夫曼树的带权路径长度；求哈夫曼树的长度，这两个问法一样，只需对应的权值乘以对应的层数，并且权值只出现一次！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/05/20/hello-world/"/>
      <url>2021/05/20/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Maven项目入门</title>
      <link href="2021/05/06/Maven%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
      <url>2021/05/06/Maven%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Maven是什么"><a href="#一、Maven是什么" class="headerlink" title="一、Maven是什么"></a>一、Maven是什么</h1><p>Maven是Apache下的一个纯java开发的开源项目，它是一个项目管理工具，使用maven对java项目进行构建、依赖管理。</p><p>通俗的来说Maven就是一款帮助程序员构建项目的工具，我们只需要告诉Maven需要哪些Jar 包，它会帮助我们下载所有的Jar，极大提升开发效率。</p><h1 id="二、Maven的安装及配置"><a href="#二、Maven的安装及配置" class="headerlink" title="二、Maven的安装及配置"></a>二、Maven的安装及配置</h1><h2 id="1-Maven本地安装"><a href="#1-Maven本地安装" class="headerlink" title="1.Maven本地安装"></a>1.Maven本地安装</h2><p>去apache官网下载，选择二进制的包</p><h2 id="2-配置环境变量"><a href="#2-配置环境变量" class="headerlink" title="2.配置环境变量"></a>2.配置环境变量</h2><p>找到Path里添加meven的安装路径，例如我的是F:\apache-maven-3.8.1\bin</p><p>在用户变量中添加M2_HOME变量,变量值为F:\apache-maven-3.8.1</p><p>然后检验打开cmd输入mvn  -v</p><p>结果会显示</p><p>Apache Maven 3.8.1 (05c21c65bdfed0f71a2f2ada8b84da59348c4c5d)<br>Maven home: F:\apache-maven-3.8.1\bin..<br>Java version: 1.8.0_201, vendor: Oracle Corporation, runtime: C:\Program Files\Java\jdk1.8.0_201\jre<br>Default locale: zh_CN, platform encoding: GBK<br>OS name: “windows 10”, version: “10.0”, arch: “amd64”, family: “windows”</p><p>类似上面的语句，如果出现那么成功</p><h2 id="3-修改maven配置文件"><a href="#3-修改maven配置文件" class="headerlink" title="3.修改maven配置文件"></a>3.修改maven配置文件</h2><p>maven会将从中央仓库下载的jar包放到本地仓库中，而这个本地仓库其实就是maven帮我们建立的一个文件夹，目录为C:\Users\你的用户名.m2\repository，这个路径是可以修改的；我们修改到F盘。</p><p>方法：找到下载好的maven文件下的conf目录，找到settings.xml文件，将路径修改。</p><p><localRepository>F:\repository</localRepository></p><p>只需添加上面那一句如图所示</p><p><img src="https://cdn.jsdelivr.net/gh/yankuncui/blogpicture/img/lk.png" alt="lk"></p><p>配置中央仓库镜像</p><p>在settings.xml文件中找的mirrors标签中添加子标签</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 阿里云仓库 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/repositories/central/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">&lt;!-- 中央仓库1 --&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">id</span>&gt;</span>repo1<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">name</span>&gt;</span>Human Readable Name for this Mirror.<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repo1.maven.org/maven2/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!-- 中央仓库2 --&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>repo2<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">name</span>&gt;</span>Human Readable Name for this Mirror.<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repo2.maven.org/maven2/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下载资源</p><p>打开cmd输入mvp help:system</p><p>开始下载，这样你会发现你的仓库里面有东西了</p><h1 id="三、创建项目"><a href="#三、创建项目" class="headerlink" title="三、创建项目"></a>三、创建项目</h1><p>点击FILE —-new Project选择maven，然后webapp那个然后输入路径名称什么的，注意，有个Maven home directory 需要填写你自己下载的文件路径,如F:\apache-maven-3.8.1，最后点击next等操作后创建完成，之后idea会生成一系列配置文件，过程会需要一段时间。</p><p>选择其中的index.jsp运行，结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/yankuncui/blogpicture/img/fm.png" alt="fm"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MybatisPlus入门</title>
      <link href="2021/05/05/MybatisPlus%E5%85%A5%E9%97%A8/"/>
      <url>2021/05/05/MybatisPlus%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><p>使用第三方插件：</p><p>1.导入对应的依赖</p><p>2.研究依赖如何配置</p><p>3.代码如何编写</p><p>4.提升扩展能力技术</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>1.创建数据库<code>mybatis_plus</code></p><p>2.创建user表</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> <span class="keyword">user</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span></span><br><span class="line">(</span><br><span class="line">id <span class="type">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;主键ID&#x27;</span>,</span><br><span class="line">name <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">age <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">email <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;邮箱&#x27;</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> (id, name, age, email) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;Jone&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;test1@baomidou.com&#x27;</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="string">&#x27;Jack&#x27;</span>, <span class="number">20</span>, <span class="string">&#x27;test2@baomidou.com&#x27;</span>),</span><br><span class="line">(<span class="number">3</span>, <span class="string">&#x27;Tom&#x27;</span>, <span class="number">28</span>, <span class="string">&#x27;test3@baomidou.com&#x27;</span>),</span><br><span class="line">(<span class="number">4</span>, <span class="string">&#x27;Sandy&#x27;</span>, <span class="number">21</span>, <span class="string">&#x27;test4@baomidou.com&#x27;</span>),</span><br><span class="line">(<span class="number">5</span>, <span class="string">&#x27;Billie&#x27;</span>, <span class="number">24</span>, <span class="string">&#x27;test5@baomidou.com&#x27;</span>);</span><br></pre></td></tr></table></figure><p>3.编写项目，初始化项目</p><p>新建一个springboot项目，点击spring Intializr进行创建，选择java8的环境</p><p>初始化完毕后，需要删除多余的文件，需要删除.gitignore、HELP.md、mvnw、mvnw.cmd</p><p>4.导入依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 数据库驱动--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- lombok--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--mybatics-plus--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.5.tmp<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>说明：我们mybatis-plus可以节省我们大量的代码，尽量不要同时导入mybatis与mybatis-plus版本差异</p><p>5.连接数据库与mybatis一样</p><p>点击src目录下的main找到resorces进入application.properties</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mysql  5  驱动不同，如果为8需要加入时区配置，并且要改为com.mysql.cj.jdbc.Driver,</span></span><br><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string">123456</span></span><br><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/mybatis_plus?useSSL=false&amp;&amp;useUnicode=true&amp;&amp;characterEncoding=utf-8</span></span><br><span class="line"><span class="meta">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="comment"># mysql 8</span></span><br><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/mybatis_plus?useSSL=false&amp;&amp;useUnicode=true&amp;&amp;characterEncoding=utf-8&amp;&amp;serverTimezone=GMT%2B8</span></span><br><span class="line"><span class="meta">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>将上边代码复制进去。</p><p>注：强烈建议使用mysql 8的驱动，不然最后结果可能会出错。会提示Loading class <code>com.mysql.jdbc.Driver&#39;. This is deprecated. The new driver class is </code>com.mysql.cj.jdbc.Driver’. The driver is automatical。意思是mysql 5不让用了</p><p>连接数据库：</p><p>点击项目右边的database，并点击左上角的+号，选择mysql ，输入用户名和密码，点击test connection验证是否成功</p><p>注： 6.传统方式pojo-dao(连接mybatis，配置mapper.xml文件)-service-controller</p><p>6.使用了mybatis-plus之后，不需要配置过多的文件</p><p>在java目录下创建一个包pojo,创建一个java类user类。继续在该目录下创建一个mapper包，在该包下创建一个usermapper接口继承BaseMapper接口</p><p>pojo</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import lombok.AllArgsConstructor;</span><br><span class="line">import lombok.Data;</span><br><span class="line">import lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">public class User &#123;</span><br><span class="line">    private Long id;</span><br><span class="line">    private String name;</span><br><span class="line">    private Integer age;</span><br><span class="line">    private String email;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      </span><br></pre></td></tr></table></figure><p>mapper</p><figure class="highlight plain"><figcaption><span>mapper接口</span></figcaption><table><tr><td class="code"><pre><span class="line">import com.baomidou.mybatisplus.core.mapper.BaseMapper;</span><br><span class="line">import com.kun.pojo.User;</span><br><span class="line">import org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在对应的Mapper实现基本的类 BaseMapper</span><br><span class="line">@Repository    &#x2F;&#x2F;代表持久层dao层</span><br><span class="line">public interface UserMapper extends BaseMapper&lt;User&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F;所有的增删改查已经编写完成</span><br><span class="line">&#125;</span><br><span class="line">注意：需要在主启动类上去扫描我们的mapper包下的所有接口@MapperScan(&quot;com.kun.mapper&quot;)</span><br></pre></td></tr></table></figure><p>测试类中测试</p><figure class="highlight plain"><figcaption><span>测试类中测试</span></figcaption><table><tr><td class="code"><pre><span class="line">import com.kun.mapper.UserMapper;</span><br><span class="line">import com.kun.pojo.User;</span><br><span class="line">import org.junit.jupiter.api.Test;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">@SpringBootTest</span><br><span class="line">class MabatisPlusApplicationTests &#123;</span><br><span class="line">    &#x2F;&#x2F;继承了BaseMapper,所有的方法都来自父类，也可编写自己的扩展方法</span><br><span class="line">   @Autowired</span><br><span class="line">   private UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void contextLoads() &#123;</span><br><span class="line">        &#x2F;&#x2F;参数是一个Wrapper，条件构造器,这里先不用，null</span><br><span class="line">        &#x2F;&#x2F;查询全部用户</span><br><span class="line"></span><br><span class="line">        List&lt;User&gt; users &#x3D; userMapper.selectList(null);</span><br><span class="line">        users.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/yankuncui/pictures/img/20210523202933.png" alt="img"></p><p>成功查询</p><h1 id="配置日志"><a href="#配置日志" class="headerlink" title="配置日志"></a>配置日志</h1><p>我们的所有sql现在是不可见的，希望知道它是怎么执行的，所以我们必须要看日志！</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mybatis-plus.configuration.log-impl&#x3D;org.apache.ibatis.logging.stdout.StdOutImpl</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/yankuncui/pictures/img/20210524124711.jpg" alt="666"></p><p>配置完毕后，后面的学习就需要注意这个自动生成SQL。</p><h1 id="CRUD扩展"><a href="#CRUD扩展" class="headerlink" title="CRUD扩展"></a>CRUD扩展</h1><h2 id="insert插入"><a href="#insert插入" class="headerlink" title="insert插入"></a>insert插入</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试插入</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsert</span><span class="params">()</span></span>&#123;</span><br><span class="line">       User user = <span class="keyword">new</span> User();</span><br><span class="line">       user.setName(<span class="string">&quot;李青&quot;</span>);</span><br><span class="line">       user.setAge(<span class="number">15</span>);</span><br><span class="line">       user.setEmail(<span class="string">&quot;1234234@qq.com&quot;</span>);</span><br><span class="line">       userMapper.insert(user);<span class="comment">//自动生成id</span></span><br><span class="line">       <span class="keyword">int</span> result=userMapper.insert(user);<span class="comment">//帮我们自动生成ID</span></span><br><span class="line">       System.out.println(result);<span class="comment">//受影响的行数</span></span><br><span class="line">       System.out.println(user);<span class="comment">//发现id自动回填</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/yankuncui/pictures/img/20210524161510.png" alt="is"></p><p>数据库插入的id默认值为：全局的唯一id</p><h2 id="主键生成策略"><a href="#主键生成策略" class="headerlink" title="主键生成策略"></a>主键生成策略</h2><p>雪花算法：</p><p>snowflake是Twitter开源的分布式ID生成算法，结果是一个long型的id。其核心思想是：使用41bit作为毫米数，10bit作为机器的id(5个bit是数据中心，5个bit是机器id)，12bit作为毫秒内的流水号(意味着每个节点在每个毫秒内可产生4096个id)最后还有一个符号位，永远是0。可以保证全球唯一！</p><p>主键自增</p><p>我们需要配置主键自增：</p><p>1.字体类字段加上@TableId(type = IdType.Auto)</p><p>2.数据库字段一定要自增</p><p>3.再次测试插入</p><p>其它的源码解释</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">IdType</span></span>&#123;</span><br><span class="line">    AUTO(<span class="number">0</span>),<span class="comment">//数据库ID自增</span></span><br><span class="line">    NONE(<span class="number">1</span>),<span class="comment">//未设置主键</span></span><br><span class="line">    INPUT(<span class="number">2</span>),<span class="comment">//手动输入</span></span><br><span class="line">    ID_WORKER(<span class="number">3</span>),<span class="comment">//默认的全局id</span></span><br><span class="line">    UUID(<span class="number">4</span>),全局唯一id UUid</span><br><span class="line">    ID_WORKER_STR(<span class="number">5</span>)<span class="comment">//ID_WORKER字符串表示法</span></span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p><h2 id="update更新"><a href="#update更新" class="headerlink" title="update更新"></a>update更新</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//更新测试</span></span><br><span class="line"> <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setId(<span class="number">5L</span>);</span><br><span class="line">        user.setName(<span class="string">&quot;666&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> i=userMapper.updateById(user);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>结果如下:</p><p><img src="https://cdn.jsdelivr.net/gh/yankuncui/pictures/img/20210524142509.png" alt="up"></p><h2 id="Delete删除操作"><a href="#Delete删除操作" class="headerlink" title="Delete删除操作"></a>Delete删除操作</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除测试</span></span><br><span class="line"><span class="comment">//测试删除</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDelete</span><span class="params">()</span></span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        <span class="keyword">int</span> i=userMapper.deleteById(<span class="number">5L</span>);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/yankuncui/pictures/img/20210524142530.png" alt="del"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>搭建个人图床</title>
      <link href="2021/05/05/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%9B%BE%E5%BA%8A/"/>
      <url>2021/05/05/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%9B%BE%E5%BA%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="一、软件准备"><a href="#一、软件准备" class="headerlink" title="一、软件准备"></a>一、软件准备</h1><p>Typora(用于博客文本编写)</p><p>PicGo(用于同步git图片仓库)</p><h1 id="二、搭建个人图床"><a href="#二、搭建个人图床" class="headerlink" title="二、搭建个人图床"></a>二、搭建个人图床</h1><h2 id="1-新建仓库"><a href="#1-新建仓库" class="headerlink" title="1.新建仓库"></a>1.新建仓库</h2><p>首先进入github新建个人仓库，如blogpicture。</p><h2 id="2-获取token"><a href="#2-获取token" class="headerlink" title="2.获取token"></a>2.获取token</h2><p>在个人头像那里，点击setting，选择Deployer settings，在私人令牌中，选择repo权限，然后提交</p><p>保存token即可</p><h2 id="3-PicGo设置"><a href="#3-PicGo设置" class="headerlink" title="3.PicGo设置"></a>3.PicGo设置</h2><p>参数说明：</p><p>仓库名：表示远程仓库地址，固定格式 Github用户名/仓库名，前期准备用到的仓库<br>分支名：表示分支，默认填入master，需要根据自己Github上的分支进行填写<br>Token：填入Github中生成的Token，上面已经讲解过Token获取<br>存储路径：可以自定义一个文件路径<br>自定义域名：建议使用<a href="https://cdn.jsdelivr.net/gh/Github%E7%94%A8%E6%88%B7%E5%90%8D/%E4%BB%93%E5%BA%93%E5%90%8D">https://cdn.jsdelivr.net/gh/Github用户名/仓库名</a></p><h2 id="4-Typora设置"><a href="#4-Typora设置" class="headerlink" title="4.Typora设置"></a>4.Typora设置</h2><p>点击image，在when Insert下选择 Upload image,勾选4个A开头的，在image  Upload </p><p>Setting选择PicGo.app</p><h1 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h1><p>选择任意一张图片复制，然后粘贴在typora文本编辑中会生成一个网址，并且PicGo会提示上传成功，<br>根据网址可以通过浏览器访问图片，如<a href="https://cdn.jsdelivr.net/gh/yankuncui/blogpicture/img/ch.jpg%E3%80%82">https://cdn.jsdelivr.net/gh/yankuncui/blogpicture/img/ch.jpg。</a><br><img src="https://cdn.jsdelivr.net/gh/yankuncui/blogpicture/img/ch.jpg" alt="ch"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>jsp项目之连接数据库</title>
      <link href="2021/04/28/jsp%E9%A1%B9%E7%9B%AE%E4%B9%8B%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>2021/04/28/jsp%E9%A1%B9%E7%9B%AE%E4%B9%8B%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="一、连接数据库步骤-以IDEA为例"><a href="#一、连接数据库步骤-以IDEA为例" class="headerlink" title="一、连接数据库步骤(以IDEA为例)"></a>一、连接数据库步骤(以IDEA为例)</h1><p>1.安装数据驱动的jar包。<br>2.找到安装Tomcat文件，找到lib文件夹，将下载好jdbc驱动jar包复制进去。<br>3.右键点击File,接着点击ProjectStructure或者使用快捷件Ctrl+alt+shift+s调用。<br>点击Libraries并点击右上的+号，选择Java将你下载的Jdbc驱动找到，点击OK。</p><h1 id="二、连接数据库代码"><a href="#二、连接数据库代码" class="headerlink" title="二、连接数据库代码"></a>二、连接数据库代码</h1><p>代码如下：<br>Connection con;<br>Statement stmt;<br>ResultSet rs;<br> Class.forName(“com.mysql.jdbc.Driver”);<br>String url=”jdbc:mysql://localhost:3306/student”;<br>con=DriverManager.getConnection(“url”,”root”,”admin”);//root指的是数据库名，admin指的是密码。<br>stmt=con.createStatement();<br>String sql=”sql语句”//select或delete或insert或update语句<br>rs=stmt.exectuteQuery(sql)或者rs=stmt.executeUpdate(sql);</p><h1 id="三、具体实例"><a href="#三、具体实例" class="headerlink" title="三、具体实例"></a>三、具体实例</h1><h2 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h2><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;查询会员信息&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body bgcolor&#x3D;&quot;#f5f5dc&quot;&gt;</span><br><span class="line">&lt;div align&#x3D;&quot;center&quot;&gt;</span><br><span class="line">&lt;table border&#x3D;&quot;2&quot;&gt;                                    </span><br><span class="line">&lt;tr align&#x3D;&quot;center&quot;&gt;</span><br><span class="line">&lt;th colspan&#x3D;&quot;5&quot;&gt;&lt;&#x2F;th&gt;</span><br><span class="line">&lt;&#x2F;tr&gt;</span><br><span class="line">&lt;tr align&#x3D;&quot;center&quot;&gt;</span><br><span class="line">&lt;th&gt;会员名称&lt;&#x2F;th&gt;</span><br><span class="line">&lt;th&gt;会员性别&lt;&#x2F;th&gt;</span><br><span class="line">&lt;th&gt;会员邮箱&lt;&#x2F;th&gt;</span><br><span class="line">&lt;th&gt;会员电话&lt;&#x2F;th&gt;</span><br><span class="line">&lt;th&gt;会员学历&lt;&#x2F;th&gt;</span><br><span class="line">&lt;&#x2F;tr&gt;</span><br><span class="line">&lt;%</span><br><span class="line">      Connection con;</span><br><span class="line">      java.sql.Statement stmt;</span><br><span class="line">      ResultSet rs;</span><br><span class="line">      Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">      con&#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;student&quot;,&quot;student&quot;,&quot;123456&quot;);</span><br><span class="line">      stmt&#x3D;con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE,ResultSet.CONCUR_READ_ONLY);</span><br><span class="line">      rs&#x3D;stmt.executeQuery(&quot;select *from hy&quot;);</span><br><span class="line">      while(rs.next())&#123;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td&gt;&lt;%&#x3D;rs.getString(&quot;mc&quot;)%&gt;&lt;&#x2F;td&gt;</span><br><span class="line">&lt;td&gt;&lt;%&#x3D;rs.getString(&quot;sex&quot;)%&gt;&lt;&#x2F;td&gt;</span><br><span class="line">&lt;td&gt;&lt;%&#x3D;rs.getString(&quot;xx&quot;)%&gt;&lt;&#x2F;td&gt;</span><br><span class="line">&lt;td&gt;&lt;%&#x3D;rs.getString(&quot;tel&quot;)%&gt;&lt;&#x2F;td&gt;</span><br><span class="line">&lt;td&gt;&lt;%&#x3D;rs.getString(&quot;xl&quot;)%&gt;&lt;&#x2F;td&gt;</span><br><span class="line">&lt;&#x2F;tr&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;&#x2F;table&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/yankuncui/blogpicture/img/sjk.png" alt="sjk"></p><p>注：添加信息，修改信息，删除信息与上篇文章类似，可以根据需要简单修改。<br>本例是为了方便之后jsp项目连接数据库。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java项目之连接数据库</title>
      <link href="2021/04/26/Java%E9%A1%B9%E7%9B%AE%E4%B9%8B%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>2021/04/26/Java%E9%A1%B9%E7%9B%AE%E4%B9%8B%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="一、连接数据库步骤-以eclipse为例"><a href="#一、连接数据库步骤-以eclipse为例" class="headerlink" title="一、连接数据库步骤(以eclipse为例)"></a>一、连接数据库步骤(以eclipse为例)</h1><p>1.首先需要安装一个驱动的jar包。<br>2.然后右键点击所创的Java项目，点击build path之后继续点击Add External Archieves，找到<br>  你安装的jar包，点击打开。<br>3.编写连接数据库的代码，进行增删改查。</p><h1 id="二、连接数据库的Java代码块"><a href="#二、连接数据库的Java代码块" class="headerlink" title="二、连接数据库的Java代码块"></a>二、连接数据库的Java代码块</h1><p>代码如下：<br>Connection con;<br>Statement stmt;<br>ResultSet rs;<br> Class.forName(“com.mysql.jdbc.Driver”);<br>String url=”jdbc:mysql://localhost:3306/student”;<br>con=DriverManager.getConnection(“url”,”root”,”admin”);//root指的是数据库名，admin指的是密码。<br>stmt=con.createStatement();<br>String sql=”sql语句”//select或delete或insert或update语句<br>rs=stmt.exectuteQuery(sql)或者rs=stmt.executeUpdate(sql);</p><h1 id="三、具体实例"><a href="#三、具体实例" class="headerlink" title="三、具体实例"></a>三、具体实例</h1><h2 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Connection con;</span><br><span class="line">java.sql.Statement stmt;</span><br><span class="line">ResultSet rs;</span><br><span class="line">try &#123;</span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">&#125;catch (ClassNotFoundException ex) &#123;</span><br><span class="line">System.out.println(&quot;error:&quot;+ex);</span><br><span class="line">&#125;</span><br><span class="line">try &#123;</span><br><span class="line">con&#x3D;DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;student&quot;,&quot;student&quot;,&quot;123456&quot;);</span><br><span class="line"> stmt&#x3D;con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE,ResultSet.CONCUR_READ_ONLY);</span><br><span class="line"> rs&#x3D;stmt.executeQuery(&quot;select *from sb&quot;);</span><br><span class="line">rs.last();</span><br><span class="line">int k&#x3D;rs.getRow();</span><br><span class="line"> if(k&#x3D;&#x3D;0) &#123;</span><br><span class="line">JOptionPane.showMessageDialog(this,&quot;你查询的表为空表&quot;,&quot;系统提示&quot;,JOptionPane.WARNING_MESSAGE);</span><br><span class="line">&#125;</span><br><span class="line">rs.beforeFirst();</span><br><span class="line">String ob[][]&#x3D;new String[k][6];</span><br><span class="line">for(int i&#x3D;0;(i&lt;k)&amp;&amp;(rs.next());i++) &#123;</span><br><span class="line">ob[i][0]&#x3D;rs.getString(&quot;sbid&quot;);</span><br><span class="line">ob[i][1]&#x3D;rs.getString(&quot;sblb&quot;);</span><br><span class="line">ob[i][2]&#x3D;rs.getString(&quot;dt&quot;);</span><br><span class="line">ob[i][3]&#x3D;rs.getString(&quot;sname&quot;);</span><br><span class="line">ob[i][4]&#x3D;rs.getString(&quot;sbzt&quot;);</span><br><span class="line">ob[i][5]&#x3D;rs.getString(&quot;sbbm&quot;);</span><br><span class="line">&#125;</span><br><span class="line">String s[]&#x3D; &#123;&quot;设备编号&quot;,&quot;设备类别&quot;,&quot;出厂日期&quot;,&quot;设备名称&quot;,&quot;设备状态&quot;,&quot;设备所属部门&quot;&#125;;</span><br><span class="line">jt&#x3D;new JTable(ob,s);</span><br><span class="line">jt.setSize(700,700);</span><br><span class="line">JScrollPane jsp&#x3D;new JScrollPane(jt);</span><br><span class="line">jsp.setPreferredSize(new Dimension(jt.getWidth()-100,jt.getHeight()-100));</span><br><span class="line">p1.add(jsp,&quot;Center&quot;);</span><br><span class="line">con.close();</span><br><span class="line">&#125;catch(Exception e) &#123;</span><br><span class="line">e.printStackTrace(); </span><br><span class="line">&#125;</span><br><span class="line">this.add(p1);</span><br><span class="line">p1.setVisible(true);</span><br><span class="line">this.setVisible(true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="增加信息"><a href="#增加信息" class="headerlink" title="增加信息"></a>增加信息</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Connection conn;</span><br><span class="line">Statement stmt;</span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">conn&#x3D;DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;student&quot;,&quot;student&quot;,&quot;123456&quot;);</span><br><span class="line">stmt&#x3D;conn.createStatement();</span><br><span class="line">String sbid&#x3D;jt[0].getText();            </span><br><span class="line">String sblb&#x3D; jt[1].getText();</span><br><span class="line">String dt&#x3D;jt[2].getText();</span><br><span class="line">String sname&#x3D;jt[3].getText()；</span><br><span class="line">String sbzt&#x3D;jt[4].getText();</span><br><span class="line">String sbbm&#x3D;jt[5].getText();</span><br><span class="line">String sql&#x3D;&quot;insert into sb &quot;+&quot; (sbid,sblb,dt,sname,sbzt,sbbm)&quot;+&quot;values(&#39;&quot;+sbid+&quot;&#39;,&#39;&quot;+sblb+&quot;&#39;,&#39;&quot;+dt+&quot;&#39;,&#39;&quot;+sname+&quot;&#39;,&#39;&quot;+sbzt+&quot;&#39;,&#39;&quot;+sbbm+&quot;&#39;)&quot;;</span><br><span class="line">stmt.executeUpdate(sql); </span><br><span class="line">stmt.close();</span><br><span class="line">conn.close();</span><br></pre></td></tr></table></figure><h2 id="删除信息"><a href="#删除信息" class="headerlink" title="删除信息"></a>删除信息</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Connection conn;</span><br><span class="line">Statement stmt;</span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">conn&#x3D;DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;student&quot;,&quot;student&quot;,&quot;123456&quot;);</span><br><span class="line">stmt&#x3D;conn.createStatement();</span><br><span class="line">String sbid&#x3D;jt[0].getText();            </span><br><span class="line">String sblb&#x3D; jt[1].getText();</span><br><span class="line">String dt&#x3D;jt[2].getText();</span><br><span class="line">String sname&#x3D;jt[3].getText();            </span><br><span class="line">String sbzt&#x3D; jt[4].getText();</span><br><span class="line">String sbbm &#x3D;jt[5].getText();</span><br><span class="line">String sql&#x3D;&quot;delete from sb where sbid&#x3D;&#39;&quot;+sbid+&quot;&#39;&quot;;</span><br><span class="line">stmt.executeUpdate(sql); </span><br><span class="line">stmt.close();</span><br><span class="line">conn.close();</span><br></pre></td></tr></table></figure><h2 id="修改信息"><a href="#修改信息" class="headerlink" title="修改信息"></a>修改信息</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Connection conn;</span><br><span class="line">Statement stmt;</span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">conn&#x3D;DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;student&quot;,&quot;student&quot;,&quot;123456&quot;);</span><br><span class="line">stmt&#x3D;conn.createStatement();</span><br><span class="line">String sbid&#x3D;jt[0].getText();            </span><br><span class="line">String sblb&#x3D; jt[1].getText();</span><br><span class="line">String dt&#x3D;jt[2].getText();</span><br><span class="line">String sname&#x3D;jt[3].getText();</span><br><span class="line">String sbzt&#x3D;jt[4].getText();</span><br><span class="line">String sbbm&#x3D;jt[5].getText();</span><br><span class="line">String sql&#x3D;&quot;update sb set sbid&#x3D;&#39;&quot;+sbid+&quot;&#39;,sblb&#x3D;&#39;&quot;+sblb+&quot;&#39;,dt&#x3D;&#39;&quot;+dt+&quot;&#39;,sname&#x3D;&#39;&quot;+sname+&quot;&#39;,sbzt&#x3D;&#39;&quot;+sbzt+&quot;&#39;,sbbm&#x3D;&#39;&quot;+sbbm+&quot;&#39; </span><br><span class="line">where sbid&#x3D;&#39;&quot;+sbid+&quot;&#39;&quot;;</span><br><span class="line">stmt.executeUpdate(sql); </span><br><span class="line">stmt.close();</span><br><span class="line">conn.close();</span><br></pre></td></tr></table></figure><p>注：本例是以实验室设备信息建表进行增删改查操作，其中查询将得到的信息建表后加入到面板中<br>，然后增删改代码执行过后，通过再次调用查询类查看进行增删改操作后的表信息。本例是为了方便<br>之后Java项目连接数据库。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>贪心算法</title>
      <link href="2021/04/18/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
      <url>2021/04/18/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="一、贪心算法的基本思想"><a href="#一、贪心算法的基本思想" class="headerlink" title="一、贪心算法的基本思想"></a>一、贪心算法的基本思想</h1><p>贪心算法是指在对问题求解时，总是做出在当前看来是最好的选择。也就是说，<br>不从整体最优上加以考虑，它所做出的仅是在某种意义上的局部最优解。用局<br>部解构造全局解，即从问题的某一个初始解逐步逼近给定的目标，以尽可能快<br>的求得更好的解。当某个算法中的某一步不能再继续前进时，算法停止。</p><hr><h1 id="二、贪心算法存在问题"><a href="#二、贪心算法存在问题" class="headerlink" title="二、贪心算法存在问题"></a>二、贪心算法存在问题</h1><p>(1)不能保证解释最佳的。因为贪心算法总是从局部出发，并没有从整体考虑。<br>(2)贪心算法一般用来解决求最大或最小解。<br>(3)贪心算法只能确定某些问题的可行性范围。</p><hr><h1 id="三、贪心算法的实现过程"><a href="#三、贪心算法的实现过程" class="headerlink" title="三、贪心算法的实现过程"></a>三、贪心算法的实现过程</h1><p>贪心算法的核心问题是选择能产生问题最优解的最优度量标准，即贪心策略。<br>所谓贪心策略是指从问题的.初始状态出发，通过若干次的贪心选择而得出最<br>优值的一种解题方法，其具体的实现<br>过程如下：<br>(1)应用同一规则，将原问题变为一个相似的但规模更小的子问题。<br>(2)从问题的某一初始解出发：<br>      while （能朝给定目标前进一步）<br>              求出可行解的一个解元素<br>(3)由所有解元素组合成问题的一个可行解</p><h2 id="四、具体实例"><a href="#四、具体实例" class="headerlink" title="四、具体实例"></a>四、具体实例</h2><p>有N堆纸牌，编号分别为1，2，…，n。每堆上有若干张,但纸牌总数必为n的倍数.<br>可以在任一堆上取若干张纸牌,然后移动。移牌的规则为：在编号为1上取的纸牌，<br>只能移到编号为2的堆上；在编号为n的堆上取的纸牌，只能移到编号为n-1的堆上；<br>其他堆上取的纸牌，可以移到相邻左边或右边的堆上。现在要求找出一种移动方法，<br>用最少的移动次数使每堆上纸牌数都一样多。例如：n=4，4堆纸牌分别为：<br>① 9 ② 8 ③ 17 ④ 6 移动三次可以达到目的：从③取4张牌放到④<br> 再从③区3张放到②然后从②去1张放到①。</p><p>样例输入<br>4<br>9 8 17 6<br>样例输出<br>3</p><p>代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Greedy &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">  int n &#x3D; 0, avg &#x3D;0, s &#x3D; 0;</span><br><span class="line">  Scanner scanner &#x3D; new Scanner(System.in);</span><br><span class="line">  ArrayList&lt;Integer&gt; array &#x3D; new ArrayList&lt;Integer&gt;();</span><br><span class="line">  System.out.println(&quot;Please input the number of heaps:&quot;);</span><br><span class="line">  n &#x3D; scanner.nextInt();</span><br><span class="line">  System.out.println(&quot;Please input heap number:&quot;);</span><br><span class="line">  for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">   array.add(scanner.nextInt());</span><br><span class="line">  &#125;</span><br><span class="line">  for(int i &#x3D; 0; i &lt; array.size(); i ++)&#123;</span><br><span class="line">   avg +&#x3D; array.get(i);</span><br><span class="line">  &#125;</span><br><span class="line">  avg &#x3D; avg&#x2F;array.size();</span><br><span class="line">  System.out.println(array.size());</span><br><span class="line">  System.out.println(avg);</span><br><span class="line">  for(int i &#x3D; 0; i &lt; array.size()-1; i ++)&#123;</span><br><span class="line">   s++;</span><br><span class="line">   array.set(i+1, array.get(i+1)+array.get(i)-avg);   </span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(&quot;s:&quot; + s);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>枚举算法</title>
      <link href="2021/04/17/%E6%9E%9A%E4%B8%BE%E7%AE%97%E6%B3%95/"/>
      <url>2021/04/17/%E6%9E%9A%E4%B8%BE%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="一、枚举算法的思想"><a href="#一、枚举算法的思想" class="headerlink" title="一、枚举算法的思想"></a>一、枚举算法的思想</h1><h2 id="枚举算法的定义"><a href="#枚举算法的定义" class="headerlink" title="枚举算法的定义"></a>枚举算法的定义</h2><p>在进行归纳推理时，如果逐个考察了某类事件的所有可能情况，因而得出一般结论，那么该结论是可靠 的，<br>这种归纳方法叫做枚举法。</p><h2 id="枚举算法的思想"><a href="#枚举算法的思想" class="headerlink" title="枚举算法的思想"></a>枚举算法的思想</h2><p>将问题的所有可能的答案一一列举，然后根据条件判断此答案是否合适，保留合适的，舍弃不合适的。</p><h2 id="使用枚举算法解题的基本思路"><a href="#使用枚举算法解题的基本思路" class="headerlink" title="使用枚举算法解题的基本思路"></a>使用枚举算法解题的基本思路</h2><p>（1）确定枚举对象、范围和判定条件。<br>（2）逐一枚举可能的解并验证每个解是否是问题的解。</p><h2 id="枚举算法步骤"><a href="#枚举算法步骤" class="headerlink" title="枚举算法步骤"></a>枚举算法步骤</h2><p>（1）确定解题的可能范围，不能遗漏任何一个真正解，同时避免重复。<br>（2）判定是否是真正解的方法。<br>（3）为了提高解决问题的效率，使可能解的范围将至最小。</p><hr><h1 id="二、算法实例"><a href="#二、算法实例" class="headerlink" title="二、算法实例"></a>二、算法实例</h1><p>题目描述<br>观察数字：12321，123321都有一个共同的特征，无论从左往右读，还是从右往左读，都是相同的，<br>上述数字称为回文数字。</p><p>现在要从5位或6位的十进制数字中找出各个位数之后等n的回文数字。</p><p>输入格式<br>输入一个整数n(10&lt;n&lt;=100)</p><p>输出格式<br>输出所有个位数之和等于n的5位和6位整数，每个数字占一行，数字从小到大的顺序排列。<br>如果没有满足的数字，则输出-1。<br>样例输入<br>48</p><p>样例输出<br>699996<br>789987<br>798897<br>879978<br>888888<br>897798<br>969969<br>978879<br>987789<br>996699</p><p>代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n;</span><br><span class="line">int digit[6];</span><br><span class="line">bool jug(int x)&#123;</span><br><span class="line">int m&#x3D;0,sum&#x3D;0;</span><br><span class="line">while(x)&#123;</span><br><span class="line">digit[m++]&#x3D;x%10;</span><br><span class="line">sum+&#x3D;x%10;</span><br><span class="line">x&#x2F;&#x3D;10;</span><br><span class="line">&#125;</span><br><span class="line">if(sum!&#x3D;n)&#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">for(int i&#x3D;0;i&lt;m&#x2F;2;i++)&#123;</span><br><span class="line">if(digit[i]!&#x3D;digit[m-1-i])</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">bool f&#x3D;false;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">for(int i&#x3D;10000;i&lt;1000000;i++)&#123;</span><br><span class="line">if(jug(i))&#123;</span><br><span class="line">cout&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">f&#x3D;true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(!f)&#123;</span><br><span class="line">cout&lt;&lt;-1&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><hr><p>题目描述<br>方程a^2+b^2+c^2=n，其中0&lt;a&lt;b&lt;c。请你求出它的所有解，结果按照<br>a的值从小到大输出。</p><p>输入格式<br>输入一个整数n，为方程等号右边的整数。</p><p>输出格式<br>输出若干行，每行包括三个空格隔开的整数，分别为a,b,c的值。</p><p>样例输入<br>1000</p><p>样例输出<br>6 8 30<br>10 18 24</p><p>代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">int n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">for(int a&#x3D;1;a * a&lt;&#x3D;n;a++)&#123;</span><br><span class="line">for(int b&#x3D;a+1;a * a+b * b&lt;&#x3D;n;b++)&#123;</span><br><span class="line">    for(int c&#x3D;b+1;a * a+b * b+c * c&lt;&#x3D;n;c++)&#123;</span><br><span class="line">    if(a * a+b * b+c * c&#x3D;&#x3D;n)</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;&quot; &quot;&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return  0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>题目描述<br>给定一个n x m的矩阵A。求A中的一个非空子矩阵，使这个子矩阵<br>中的元素和最大。其中，A的子矩阵是指A中行和列均连续的一部分。</p><p>输入格式<br>输入的第一行包含两个整数<br>n,m(n&gt;=1,m&lt;=50),分别表示矩阵A的行数和列数，接下来n行，每行<br>m个整数，表示矩阵Aij(-1000&lt;=Aij&lt;=1000)。</p><p>输出格式<br>输出一行，每包含一个整数，表示A中最大的子矩阵中的元素和</p><p>样例输入<br>3 3<br>2 -4 1<br>-1 2 1<br>4 -2 2</p><p>样例输出<br>6</p><p>代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int A[55][55];</span><br><span class="line">int main()&#123;</span><br><span class="line">int n,m,ans;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    ans&#x3D;-1005;</span><br><span class="line">for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">for(int j&#x3D;0;j&lt;m;j++)&#123;</span><br><span class="line">cin&gt;&gt;A[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">for(int j&#x3D;i;j&lt;n;j++)&#123;</span><br><span class="line">for(int k&#x3D;0;k&lt;m;k++)&#123;</span><br><span class="line">for(int l&#x3D;k;l&lt;m;l++)&#123;</span><br><span class="line">int tmp&#x3D;0;</span><br><span class="line">for(int p&#x3D;i;p&lt;&#x3D;j;p++)&#123;</span><br><span class="line">for(int q&#x3D;k;q&lt;&#x3D;l;q++)&#123;</span><br><span class="line">tmp+&#x3D;A[p][q];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(tmp&gt;ans)&#123;</span><br><span class="line">ans&#x3D;tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">return  0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++算法常用函数</title>
      <link href="2021/04/16/C-%E7%AE%97%E6%B3%95%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
      <url>2021/04/16/C-%E7%AE%97%E6%B3%95%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><p>string.find(string a,pos)a是子字符串，pos是查找开始的位置，不填的话默认为0，这里<br>要注意，如果不存在要找到的东西，则返回string.npos；<br>string.length()返回string长度<br>string.substr(int start,int length)start是子字符串开始的位置，lenth是子字符串的长度;<br>string.resize(int)resize可以初始化string的大小，可以让string使用scanf以及类似char[];<br>的操作；</p><hr><h2 id="char大小写转换"><a href="#char大小写转换" class="headerlink" title="char大小写转换"></a>char大小写转换</h2><p>变为大写:char =toupper(char);<br>变为小写:char =tolower(char);<br>注:在头文件#include&lt;ctype.h&gt;下使用</p><hr><p>##字符串<br>to_string():将数字转换为string类型<br>reverse(y1,y2):将y1到y2范围的元素翻转<br>string.c.str():返回一个指向正规C字符串的指针，内容与本string串相同;<br>atoi:把一字符串转换为整数int atoi(const char *nptr);<br>对于string类型需要atoi(str.c_str))</p><hr><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>fill(a,a+n,6)将数组下标为0~n-1的元素赋值为6<br>next_permutation(a,a+n)全排列<br>sort(arr,arr+n)快速排序，默认从小到大</p><hr><h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><p>vector.size() 返回vector的大小<br>vector.push_back(Elem) 在vector的最后压入元素；<br>vector.pop_back() 删除vector中最后一个元素；<br>vector.assign(begin, end) 清空容器，进行赋值操作；</p><hr><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>set.insert(Elem) 在set中插入元素；<br>set.size() 返回set的大小<br>set.find(Elem) 如果找到返回迭代器，如果没有找到，返回set.end();<br>遍历set的操作:<br>set<T>::iterator iter = set.begin();<br>for(;iter!=set.end();iter++){<br>    //do something<br>    cout&lt;&lt;*iter&lt;&lt;endl;<br>}</p><hr><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>map[Elem1]=Elem2在map中以数组的方式插入数据<br>map.find(Elem)查找成功返回iterator，失败则返回map.end();<br>map中每个元素的本质其实是pair&lt;Elem1, Elem2&gt;；pair是可以使用pair.first和pair.second<br>来表示第一个元素和第二个元素；当使用迭代器时，(*iterator).first是map的key，<br>(*iterator).second是map的value值；而在排序的时候，是无法直接对map使用sort，<br>我们可以考虑将map先转化为vector&lt;pair&lt;Elem1, Elem2&gt;&gt;来进行自定义排序。<br>其中，map和vector的转换代码为:<br>vector&lt;pair&lt;Elem1, Elem2&gt;&gt; temp(map.begin(),map.end());</p><hr><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><p>sort(a, a+length) a为第一个元素地址，length为需要排序的元素个数；<br>sort(vector.begin(), vector.end()) 这是vector排序；<br>sort(a, a+length, cmp) 其中cmp是自定一个的函数（bool cmp(a, b)）；<br>reverse(a, a+length) a为第一个元素地址，length为需要逆转的元素个数；<br>swap(a, b) 其中a，b可以是容器，可以是变量；<br>find(a, a+length, val) a为第一个元素的地址，length为查找范围，val是查找到值；<br>copy(a, a+length, b) a为输入元素地址，length为复制范围，b为输出元素首地址；<br>fill(a, a+length, val) a为初始化元素首地址，length为初始化范围，val为全部初始化的值；<br>注:在头文件 #include&lt; algorithm&gt;下使用</p><hr><h2 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h2><p>fabs(double)取double的绝对值<br>abs(int)取int的绝对值<br>round(double)对double类型的四舍五入<br>sqrt(double)返回double的算术平方根<br>注:在头文件#include&lt;math.h&gt;下使用</p><hr><h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><p>ceil(double a):向上取整<br>floor(double a):向下取整<br>count()存在于vector和string中，分别对单个数字和单个字符计数<br>count(v.begin,v.end(),n)统计v中n出现的个数</p><hr><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>sort(a, a+length) 一般是将a按照ascii码的顺序排序；<br>sort(a, a+length, cmp) 是需要自定义排序时候，按照自定义的方法排序；<br>cmp自定义函数示例如下:<br>//按照从小到大排序；<br>//其中假定是将vector<string> 排序，因此参数为string a和string b；<br>bool cmp(string a, string b){<br>    return a&lt;b;<br>}</p><hr><h2 id="最大值和最小值"><a href="#最大值和最小值" class="headerlink" title="最大值和最小值"></a>最大值和最小值</h2><p>int num[]={2,3,1,6,4,5};<br>cout&lt;&lt;”最小值是 “&lt;&lt;*min_element(num,num+6)&lt;&lt;endl;<br>cout&lt;&lt;”最大值是 “&lt;&lt;<em>max_element(num,num+6)&lt;&lt;endl;<br>//注意这个</em>，因为返回的是迭代器；<br>注:max(),min()分别求最大值与最小值</p><h2 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h2><p>int gcd(int a, int b){<br>    return b == 0 ? a : gcd(b, a % b);<br>}</p><hr><h2 id="最小公倍数"><a href="#最小公倍数" class="headerlink" title="最小公倍数"></a>最小公倍数</h2><p>int c = gcd(a, b);//最小公倍数可以利用最大公约数；<br>int lcm(int a, int b){<br>    return a*b/c;<br>}</p><hr><h2 id="set和vector之间的相互转化"><a href="#set和vector之间的相互转化" class="headerlink" title="set和vector之间的相互转化"></a>set和vector之间的相互转化</h2><p>//set初始化vector<br>vector.assign(set.begin, set.end());<br>//vector初始化set<br>set(vector.begin(), vector.end());</p><hr><h2 id="大数据的处理"><a href="#大数据的处理" class="headerlink" title="大数据的处理"></a>大数据的处理</h2><p>绝对值在10^9以内的整数要用int；<br>超过2*10^9要用long（10^18以内）；</p><hr><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><p>如果是多循环的输入输出，一般使用scanf和printf，这样会提高很多效率，以防止时间限制；<br>如果是输入输出单个固定，可以使用cin和cout；<br>如果需要格式的输出，一定使用printf；<br>万能头文件: #include&lt;bits/stdc++.h&gt;</p><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>KMP</title>
      <link href="2021/04/16/KMP/"/>
      <url>2021/04/16/KMP/</url>
      
        <content type="html"><![CDATA[<h1 id="一、KMP算法"><a href="#一、KMP算法" class="headerlink" title="一、KMP算法"></a>一、KMP算法</h1><p>在KMP算法中，对于每一个模式串都会事先计算出模式串的内部匹配信息，在匹配失败时最大的移动模式串，<br>以减少匹配次数，这样就很好的解决了BF算法的缺陷比如，当匹配失败后，最好是能够将模式字串尽量的右移<br>和主串进行匹配，右移的距离在KMP算法中是这样计算的：在已经匹配的字串中，找到最长的相同的前缀和后缀，<br>然后移动使他们重叠，这个位置就是j要回退的位置，这样j就不用每一次都回到0号位置了，每一次j回退的位置存<br>储在一个数组里，称之为next数组。</p><hr><h1 id="二、具体实现"><a href="#二、具体实现" class="headerlink" title="二、具体实现"></a>二、具体实现</h1><p>获取next数组<br>代码<br>void GetNext(int *next,const char *sub)<br>{<br>    next[0] = -1;<br>    next[1] = 0;<br>    int lensub = strlen(sub);<br>    int i = 2;//当前的i<br>    int k = 0;//前一项的K值<br>    while(i &lt; lensub)<br>    {<br>        if(k == -1 || sub[i-1] == sub[k])<br>        {<br>            next[i] = k+1;<br>            i++;<br>            k = k+1;<br>        }<br>        else<br>        {<br>            k  = next[k];<br>        }<br>    }<br>}<br>算法实现<br>int Kmp(const char *str,const char *sub,int pos)<br>{<br>    int i = pos;<br>    int j = 0;<br>    int lens = strlen(str);<br>    int lensub = strlen(sub);<br>    int *next = (int *)malloc(sizeof(int) * lensub);<br>    assert(next != NULL);<br>    GetNext(next,sub);<br>    while(j &lt; lensub &amp;&amp; i &lt; lens)<br>    {<br>        if(j == -1 || str[i] == sub[j])<br>        {<br>            i++;<br>            j++;<br>        }<br>        else<br>        {<br>            j = next[j];<br>        }<br>    }<br>    if(j &gt;= lensub)<br>    {<br>        return i-j;<br>    }<br>    else<br>    {<br>        return -1;<br>    }<br>}</p><hr><h1 id="三、实例"><a href="#三、实例" class="headerlink" title="三、实例"></a>三、实例</h1><p>题目描述<br>首先输入一行字符串，然会在输入一行子串，输出对应的next数组与子串首位在原字符串的位置</p><p>样例输入<br>sdryteygdgdyhusjk<br>eygdg</p><p>样例输出<br>next:-1 0 0 0 0<br>5<br>代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">typedef struct seqstring &#123;</span><br><span class="line">char string[100];</span><br><span class="line">int length;</span><br><span class="line">&#125;seqstring;</span><br><span class="line">void getnext(seqstring p, int next[]) &#123;</span><br><span class="line">int i, j;</span><br><span class="line">i &#x3D; 0;&#x2F;&#x2F;指向字符串每个字符的下标</span><br><span class="line">j &#x3D; -1;</span><br><span class="line">next[i] &#x3D; j;&#x2F;&#x2F;next[0]放上-1 </span><br><span class="line">while (i &lt; p.length) &#123;&#x2F;&#x2F;没有到达结尾的话 </span><br><span class="line">if (j &#x3D;&#x3D; -1 || p.string[i] &#x3D;&#x3D; p.string[j]) &#123;&#x2F;&#x2F;如果是第一个字符或遇到相同的字符</span><br><span class="line">next[++i] &#x3D; ++j;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">j &#x3D; next[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for (i &#x3D; 0;i &lt; p.length;i++) &#123;&#x2F;&#x2F;输出next[]值 </span><br><span class="line">printf(&quot;%d &quot;, next[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">int kmp(seqstring t, seqstring p, int next[]) &#123;</span><br><span class="line">int i, j;</span><br><span class="line">i &#x3D; j &#x3D; 0;</span><br><span class="line">while (i &lt; t.length &amp;&amp; j &lt; p.length) &#123;</span><br><span class="line">if (j &#x3D;&#x3D; -1 || t.string[i] &#x3D;&#x3D; p.string[j]) &#123;</span><br><span class="line">i++;j++;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">j &#x3D; next[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (j &#x3D;&#x3D; p.length) return i - p.length;</span><br><span class="line">else return -1;</span><br><span class="line">&#125;</span><br><span class="line">int  main() &#123;</span><br><span class="line">seqstring t, p;</span><br><span class="line">int next[50];</span><br><span class="line">scanf(&quot;%s&quot;, t.string);</span><br><span class="line">t.length &#x3D; strlen(t.string);</span><br><span class="line">scanf(&quot;%s&quot;, p.string);</span><br><span class="line">p.length &#x3D; strlen(p.string);</span><br><span class="line">printf(&quot;next:&quot;);</span><br><span class="line">getnext(p, next);</span><br><span class="line">printf(&quot;\n%d\n&quot;, kmp(t, p, next));</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>BF</title>
      <link href="2021/04/16/BF/"/>
      <url>2021/04/16/BF/</url>
      
        <content type="html"><![CDATA[<h1 id="一、BF算法"><a href="#一、BF算法" class="headerlink" title="一、BF算法"></a>一、BF算法</h1><p>暴力匹配(BF)算法是普通的模式匹配算法，BF算法的思想就是将目标串S的第一个字符与模式串T的第一个字符<br>与模式串的T的第一个字符进行匹配，若相等，则继续比较S的第二个和T的第二个字符；若不等，则继续比较S<br>的第二个字符和T的第一个字符，依次比较，直到得到最后的匹配结果。</p><hr><h1 id="二、具体实现"><a href="#二、具体实现" class="headerlink" title="二、具体实现"></a>二、具体实现</h1><p>下标从0开始匹配<br>int BF(const char *str,const char *sub,int pos)<br>{<br>    assert(str!=NULL&amp;&amp;sub!=NULL);<br>    int i=pos;//用i来记录S中字符的位置<br>    int j=0;//用j来记录T中字符的位置<br>    int lens=strlen(str);<br>    int lensub=strlen(sub);<br>    //当S不为空并且T不为空时，逐个进行字符的比较<br>    while(j&lt;lensub&amp;&amp;i&lt;lens)<br>    {<br>        if(str[i]==sub[i])<br>        //当S中第i个字符与T中第j个字符相等时，i向后移一个，j向后移一个<br>        {<br>            i++;<br>            j++;<br>        }<br>        else<br>        //当S中第i个字符与T中第i个字符不相等时，i回到前一个位置的下一个位置，j回到0号位置<br>        {<br>            i=i-j+1;<br>            j=0;<br>        }<br>    }<br>    if(j&gt;=lensub)   //当j走完T的长度时，也就说明T在S中匹配成功<br>    {<br>        return i-j;     //此时返回字串在主串中的下标位置，此时i在该返回下标位置+j的长度位置，所以返回i-j。<br>    }<br>    else return -1;  //匹配失败，则返回-1，因为-1下标不存在，不能返回0下标<br>}<br>下标从任意位置开始匹配<br>int BF(SString S,SString T,int pos)<br>{<br>  int i,j;<br>  i=pos;<br>  j=1;<br>  while(i&lt;=S.lenth&amp;&amp;j&lt;=T.lenth) //当检索位置i,j同时小于主串与子串长度时，执行循环<br>   {<br>    if(S.ch[i-1]==T.ch[i-1])<br>     {<br>      i++;<br>      j++;<br>     }<br>    else<br>    {<br>    i=i-j+2;<br>    j=1;<br>    }<br>if(j&gt;T.lenth)<br>   return i-T.lenth; //j&gt;T.lenth匹配成功<br>else<br>    return 0;  //否则匹配失败<br>}</p><hr><h1 id="三、实例"><a href="#三、实例" class="headerlink" title="三、实例"></a>三、实例</h1><p>题目描述<br>首先输入一行字符串，然会在输入一行子串，输出子串首位在原串的位置</p><p>样例输入<br>adsffgshgh<br>ffgsh<br>样例输出<br>4</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt; </span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#define MAXSIZE 100</span><br><span class="line">#define OK 1</span><br><span class="line">#define ERROR 0</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line"> char ch[MAXSIZE+1];</span><br><span class="line"> int length;</span><br><span class="line">&#125;SString;           &#x2F;&#x2F;定义串结构 </span><br><span class="line">int Index_BF(SString S,SString T,int pos);</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"> int pos &#x3D; 1,pos_i;</span><br><span class="line"> SString S,T;</span><br><span class="line"> gets(S.ch);</span><br><span class="line"> S.length &#x3D; strlen(S.ch); </span><br><span class="line"> gets(T.ch);</span><br><span class="line"> T.length &#x3D; strlen(T.ch);</span><br><span class="line"> pos_i &#x3D; Index_BF(S,T,pos);      &#x2F;&#x2F;调用函数获得第一次匹配到的位置 </span><br><span class="line"> printf(&quot;%d&quot;,pos_i);</span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br><span class="line">int Index_BF(SString S,SString T,int pos)</span><br><span class="line">&#123;</span><br><span class="line"> int i,j;</span><br><span class="line"> i &#x3D; pos;</span><br><span class="line"> j &#x3D; 1;</span><br><span class="line"> while(i&lt;&#x3D;S.length &amp;&amp; j&lt;&#x3D;T.length)    &#x2F;&#x2F;当检索位置i,j同时小于主串与子串长度时，执行循环 </span><br><span class="line"> &#123;</span><br><span class="line">  if(S.ch[i-1] &#x3D;&#x3D; T.ch[j-1])</span><br><span class="line">  &#123;</span><br><span class="line">   i++;</span><br><span class="line">   j++;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">   i &#x3D; i-j+2;       &#x2F;&#x2F;匹配不成功，主串回溯到i-j+2,比较后继字符 </span><br><span class="line">   j &#x3D; 1;         &#x2F;&#x2F;匹配不成功，子串回溯到j &#x3D; 1 </span><br><span class="line">  &#125; </span><br><span class="line"> &#125;</span><br><span class="line"> if(j&gt;T.length)</span><br><span class="line">  return i-T.length;      &#x2F;&#x2F;j&gt;T.length匹配成功 </span><br><span class="line"> else</span><br><span class="line">  return 0;        &#x2F;&#x2F;否则，匹配失败 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>DFS</title>
      <link href="2021/04/16/DFS/"/>
      <url>2021/04/16/DFS/</url>
      
        <content type="html"><![CDATA[<h1 id="一、DFS算法定义"><a href="#一、DFS算法定义" class="headerlink" title="一、DFS算法定义"></a>一、DFS算法定义</h1><p>深度优先搜素算法，又称DFS。DFS算法是一种搜索算法，此算法在运用时就是找一个头结点，然后沿着这个<br>头结点一直找下去，直到找到最后一个满足条件的分节点，然后再寻找另一条路径，当沿着一条路走不满足条<br>件时会自动跳入上一层节点进行判断。DFS算法是递归算法的一种。</p><hr><h1 id="二、DFS算法具体实现"><a href="#二、DFS算法具体实现" class="headerlink" title="二、DFS算法具体实现"></a>二、DFS算法具体实现</h1><p>void DFS(type n){<br>         if(符合条件){cout&lt;&lt;答案;return;}<br>         if(可以剪枝) return;<br>         for(i:1~p){<br>               选择可行决策;<br>               标记已访问该点;<br>               DFS(n+1);<br>               (还原访问现场;)<br>       }<br>}</p><p>int check(参数)<br>{<br>    if(满足条件)<br>        return 1;<br>    return 0;<br>}</p><p>void dfs(int step)<br>{<br>        判断边界<br>        {<br>            相应操作<br>        }<br>        尝试每一种可能<br>        {<br>               满足check条件<br>               标记<br>               继续下一步dfs(step+1)<br>               恢复初始状态（回溯的时候要用到）<br>        }<br>}   </p><hr><h1 id="三、剪枝"><a href="#三、剪枝" class="headerlink" title="三、剪枝"></a>三、剪枝</h1><p>1.顺序性剪枝<br>若一些题的搜索顺序对答案无影响，那么搜索顺序的不同会导致搜索树形态的改变，优先搜索分支较少的阶段，<br>此时能减少搜索的规模。<br>2.重复性剪枝<br>在搜索的时候如果有多种方式可以达到一个状态，那么我们只需要搜索一个分支足矣<br>3.可行性剪枝<br>可行性剪枝是对搜索正确性的一个保证，当分支在递归边界的时候回溯。<br>4.最优性剪枝<br>在搜索过程中，如果当前阶段的代价已经超过我们已知的最小代价，那么此时继续搜索下去没有意义。<br>5.记忆化剪枝<br>记忆搜索状态的结果，当重复遍历一个状态的时候就可以直接返回这个状态的答案，避免重复的搜索。</p><hr><h1 id="四、实例"><a href="#四、实例" class="headerlink" title="四、实例"></a>四、实例</h1><p>1.全排列问题<br>题目描述<br>对输入的多个数进行全排列</p><p>样例输入<br>1 2 3</p><p>样例输出<br>1<br>12<br>21<br>123<br>132<br>213<br>231<br>312<br>321</p><p>代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n;</span><br><span class="line">int book[10] &#x3D; &#123;0&#125;;</span><br><span class="line">int a[10];</span><br><span class="line">void dfs(int index)</span><br><span class="line">&#123;</span><br><span class="line">if(index &#x3D;&#x3D; n)  &#x2F;&#x2F;递归终止条件</span><br><span class="line">&#123;</span><br><span class="line">for(int i &#x3D; 0;i &lt; n;++i)</span><br><span class="line">    cout &lt;&lt; a[i];</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">for(int i &#x3D; 1;i &lt;&#x3D; n;++i)</span><br><span class="line">&#123;</span><br><span class="line">if(!book[i])</span><br><span class="line">&#123;</span><br><span class="line">book[i] &#x3D; 1;&#x2F;&#x2F;标记位</span><br><span class="line">a[index] &#x3D; i;&#x2F;&#x2F;把符合的数字保存到数组中</span><br><span class="line">dfs(index+1);</span><br><span class="line">a[index] &#x3D; 0;</span><br><span class="line">book[i] &#x3D; 0;&#x2F;&#x2F;还原标记，以便回溯</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">    for(int i &#x3D; 0;i &lt; 9;++i)</span><br><span class="line">    book[i] &#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">while(cin &gt;&gt; n)</span><br><span class="line">&#123;</span><br><span class="line">dfs(0);</span><br><span class="line">init();</span><br><span class="line">&#125;  </span><br><span class="line">return 0;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><hr><p>2.八皇后问题<br>题目描述<br>在国际象棋中，皇后是最厉害的棋子，可以横走、直走，还可以斜走。棋手马克斯·贝瑟尔 1848 年提出著名的八皇后问题：<br>即在 8 × 8 的棋盘上摆放八个皇后，使其不能互相攻击 —— 即任意两个皇后都不能处于同一行、同一列或同一条斜线上。<br>现在我们把棋盘扩展到 n×n 的棋盘上摆放 n 个皇后，请问该怎么摆？<br>请编写程序，输入正整数 n，输出全部摆法（棋盘格子空白处显示句点“.”，皇后处显示字母“Q”，每两个字符之间空一格）。</p><p>输入格式<br>正整数 n(n&gt;0)</p><p>输出格式<br>若问题有解，则输出全部摆法（每两种摆法之间空一行）。<br>若问题无解，则输出 None。<br>要求：试探的顺序按从上到下逐行进行，其中每一行按从左到右的逐格进行</p><p>样例输入1<br>3<br>样例输出1<br>none</p><p>样例输入2<br>6<br>样例输出2<br>. Q . . . .<br>. . . Q . .<br>. . . . . Q<br>Q . . . . .<br>. . Q . . .<br>. . . . Q .</p><p>. . Q . . .<br>. . . . . Q<br>. Q . . . .<br>. . . . Q .<br>Q . . . . .<br>. . . Q . .</p><p>. . . Q . .<br>Q . . . . .<br>. . . . Q .<br>. Q . . . .<br>. . . . . Q<br>. . Q . . .</p><p>. . . . Q .<br>. . Q . . .<br>Q . . . . .<br>. . . . . Q<br>. . . Q . .<br>. Q . . . .</p><p>代码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int  N&#x3D;20;</span><br><span class="line">char    ch[N][N];&#x2F;&#x2F;用一个二维数组来存储皇后放置的位置</span><br><span class="line">bool   col[N],l[N&lt;&lt;1],r[N&lt;&lt;1];&#x2F;&#x2F;为了数组不会越界，就把N乘2了,涉及位运算了</span><br><span class="line">bool mark;&#x2F;&#x2F;设置一个变量，判断是否有解（有解输出排法，无解输出None）</span><br><span class="line">int  n;</span><br><span class="line">&#x2F;&#x2F;这个dfs是按行逐渐进行下去的，初始值为0行</span><br><span class="line">void dfs(int x)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;如果x能够来到从初始值0来到n的位置就说明有一个解已经产生</span><br><span class="line">   if(x&#x3D;&#x3D;n)&#123;</span><br><span class="line">&#x2F;*</span><br><span class="line">加这个判断实属必要，当第一个解产生的时候，此时mark还是初始值false(0),</span><br><span class="line">所以把mark进入判断的第二个作用域，赋值为true(1),如果还有第二个解，</span><br><span class="line">此时的mark已经为true，所以输出换行，看到这里是不是有些明白了，对，没错！</span><br><span class="line">这个判断就是为了“解”与“解”之间能有个换行符而存在的！</span><br><span class="line">*&#x2F;</span><br><span class="line">       if(mark)</span><br><span class="line">       &#123;</span><br><span class="line">       cout&lt;&lt;endl;</span><br><span class="line">       &#125;</span><br><span class="line">       else</span><br><span class="line">       &#123;</span><br><span class="line">       mark&#x3D;1;</span><br><span class="line">       &#125;</span><br><span class="line">&#x2F;&#x2F;下面就是遍历这个“解”了</span><br><span class="line">for(int i&#x3D;0;i&lt;n;i++)</span><br><span class="line"> &#123;</span><br><span class="line">   for(int j&#x3D;0;j&lt;n;j++)</span><br><span class="line">   &#123;</span><br><span class="line">    cout&lt;&lt;ch[i][j];</span><br><span class="line">     if(j!&#x3D;n-1)</span><br><span class="line">     &#123;</span><br><span class="line">       cout&lt;&lt;&#39; &#39;;&#x2F;&#x2F;处理字符与字符之间的空格</span><br><span class="line">     &#125;    </span><br><span class="line">   &#125;</span><br><span class="line">  putchar(10);&#x2F;&#x2F;输出一行后需要换行，换行的ASCII数为10</span><br><span class="line"> &#125;</span><br><span class="line">return;</span><br><span class="line">       &#125;&#x2F;&#x2F;当这个“解”遍历完的时候，可以安排它消亡了</span><br><span class="line">         &#x2F;&#x2F;下面代码是这个题的核心，请务必！务必！务必！要不择一切手段也要弄懂</span><br><span class="line">&#x2F;*</span><br><span class="line">要明白下面的for循环的意思，记住是x代表行数，下面的i代表的是x行i列,</span><br><span class="line">如果不明白，请反复看，已经是保姆式教学了，</span><br><span class="line">*&#x2F;</span><br><span class="line">  for(int i&#x3D;0;i&lt;n;i++)</span><br><span class="line"> &#123; </span><br><span class="line">&#x2F;&#x2F;下面的判断是核心中核心:</span><br><span class="line">&#x2F;&#x2F;第一个判断col[i]是判断i列能不能放，col[i]&#x3D;1,说明不能放（因为下面的判断是！col[i]）</span><br><span class="line">&#x2F;&#x2F;第二个判断l[x+i]是判断主对角线能不能放，</span><br><span class="line">&#x2F;&#x2F;第三个判断r[n-x+i]是判断副对角线能不能放，</span><br><span class="line">&#x2F;&#x2F;第二第三个如果不能理解，建议直接强记模板！</span><br><span class="line">     if(!col[i]&amp;&amp;!l[x+i]&amp;&amp;!r[n-x+i])</span><br><span class="line">    &#123;</span><br><span class="line">    col[i]&#x3D;l[x+i]&#x3D;r[n-x+i]&#x3D;1;&#x2F;&#x2F;如果能放，对状态进行标记</span><br><span class="line">    ch[x][i]&#x3D;&#39;Q&#39;;</span><br><span class="line">    dfs(x+1);&#x2F;&#x2F;第一行结束，对下一行进行判断,都x+1了，你说是不是下一行</span><br><span class="line">&#x2F;&#x2F;对该坐标进行归“零”处理</span><br><span class="line">     ch[x][i]&#x3D;&#39;.&#39;;</span><br><span class="line">    col[i]&#x3D;l[x+i]&#x3D;r[n-x+i]&#x3D;0;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;这个就是对数组进行初始化处理，如果不知道的建议搜memset()详解</span><br><span class="line">memset(ch,&#39;.&#39;,sizeof(ch));&#x2F;&#x2F;初始化地图数组,这个函数在cstring这个头文件下面</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">dfs(0);&#x2F;&#x2F;这个就没得说了，从第一行开始遍历，0就是第一行。</span><br><span class="line">&#x2F;&#x2F;无解就输出None咯！</span><br><span class="line">if(!mark)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;&quot;None&quot;;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>排序</title>
      <link href="2021/04/14/%E6%8E%92%E5%BA%8F/"/>
      <url>2021/04/14/%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>题目描述<br>对输入的n个数进行从小到大排序</p><p>样例输入<br>5<br>1 3 2 5 4<br>样例输出<br>1 2 3 4 5</p><hr><h2 id="冒泡法"><a href="#冒泡法" class="headerlink" title="冒泡法"></a>冒泡法</h2><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">int a[100];</span><br><span class="line">int i,j,n,t;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">for(i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line">for(j&#x3D;0;j&lt;n-1;j++)&#123;</span><br><span class="line">  for(i&#x3D;0;i&lt;n-1-j;i++)&#123;</span><br><span class="line">    if(a[i]&gt;a[i+1])</span><br><span class="line">    &#123;</span><br><span class="line">     t&#x3D;a[i];</span><br><span class="line">     a[i]&#x3D;a[i+1];</span><br><span class="line">     a[i+1]&#x3D;t;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">for(i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">printf(&quot;%d &quot;,a[i]);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="选择法"><a href="#选择法" class="headerlink" title="选择法"></a>选择法</h2><p>代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">int a[100];</span><br><span class="line">int i,j,k,n,t;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">for(i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line">for(i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">k&#x3D;i;</span><br><span class="line">for(j&#x3D;i+1;j&lt;n;j++)&#123;</span><br><span class="line">if(a[k]&gt;a[j])</span><br><span class="line">k&#x3D;j;</span><br><span class="line">if(k!&#x3D;i)</span><br><span class="line">&#123;</span><br><span class="line">t&#x3D;a[i];</span><br><span class="line">a[i]&#x3D;a[k];</span><br><span class="line">a[k]&#x3D;t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">printf(&quot;%d &quot;,a[i]);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客文章</title>
      <link href="2021/04/11/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/"/>
      <url>2021/04/11/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p>代码：<br>#include&lt;stdio.h&gt;<br>int main()<br>{<br>printf(“hello world”)<br>return 0;<br>}</p><hr><h2 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h2><p>代码：<br>#include&lt;bits/stdc++.h&gt;<br>using namespace std;<br>int main()<br>{<br>cout&lt;&lt;”hello world”;<br>return 0;<br>}</p><hr><h2 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h2><p>代码：<br>public class helloworld{<br>      public static void main(String args[]{<br>             System.out.println(“hello world”);<br>    }<br>}</p><hr><h2 id="PYTHON"><a href="#PYTHON" class="headerlink" title="PYTHON"></a>PYTHON</h2><p>代码：<br>print(“hello world”)</p><hr>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
