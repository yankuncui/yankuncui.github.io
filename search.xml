<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>jsp项目之连接数据库</title>
      <link href="2021/04/28/jsp%E9%A1%B9%E7%9B%AE%E4%B9%8B%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>2021/04/28/jsp%E9%A1%B9%E7%9B%AE%E4%B9%8B%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="一、连接数据库步骤-以IDEA为例"><a href="#一、连接数据库步骤-以IDEA为例" class="headerlink" title="一、连接数据库步骤(以IDEA为例)"></a>一、连接数据库步骤(以IDEA为例)</h1><p>1.安装数据驱动的jar包。<br>2.找到安装Tomcat文件，找到lib文件夹，将下载好jdbc驱动jar包复制进去。<br>3.右键点击File,接着点击ProjectStructure或者使用快捷件Ctrl+alt+shift+s调用。<br>点击Libraries并点击右上的+号，选择Java将你下载的Jdbc驱动找到，点击OK。</p><h1 id="二、连接数据库代码"><a href="#二、连接数据库代码" class="headerlink" title="二、连接数据库代码"></a>二、连接数据库代码</h1><p>代码如下：<br>Connection con;<br>Statement stmt;<br>ResultSet rs;<br> Class.forName(“com.mysql.jdbc.Driver”);<br>String url=”jdbc:mysql://localhost:3306/student”;<br>con=DriverManager.getConnection(“url”,”root”,”admin”);//root指的是数据库名，admin指的是密码。<br>stmt=con.createStatement();<br>String sql=”sql语句”//select或delete或insert或update语句<br>rs=stmt.exectuteQuery(sql)或者rs=stmt.executeUpdate(sql);</p><h1 id="三、具体实例"><a href="#三、具体实例" class="headerlink" title="三、具体实例"></a>三、具体实例</h1><h2 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h2><p>代码如下：<br>&lt;%@ page contentType=”text/html;charset=UTF-8” language=”java” %&gt;</p><html><head><title>查询会员信息</title></head><body bgcolor="#f5f5dc"><div align="center"><tbale border="2">//为了防止表格在博客自己运行显示故将table写为tbale                                         <tr align="center"><th colspan="5"></th></tr><tr align="center"><th>会员名称</th><th>会员性别</th><th>会员邮箱</th><th>会员电话</th><th>会员学历</th></tr><%      Connection con;      java.sql.Statement stmt;      ResultSet rs;      Class.forName("com.mysql.jdbc.Driver");      con= DriverManager.getConnection("jdbc:mysql://localhost:3306/student","student","123456");      stmt=con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE,ResultSet.CONCUR_READ_ONLY);      rs=stmt.executeQuery("select *from hy");      while(rs.next()){%><tr><td><%=rs.getString("mc")%></td><td><%=rs.getString("sex")%></td><td><%=rs.getString("xx")%></td><td><%=rs.getString("tel")%></td><td><%=rs.getString("xl")%></td></tr><%    }%></tbale></div></body></html>注：添加信息，修改信息，删除信息与上篇文章类似，可以根据需要简单修改。本例是为了方便之后jsp项目连接数据库。]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java项目之连接数据库</title>
      <link href="2021/04/26/Java%E9%A1%B9%E7%9B%AE%E4%B9%8B%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>2021/04/26/Java%E9%A1%B9%E7%9B%AE%E4%B9%8B%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="一、连接数据库步骤-以eclipse为例"><a href="#一、连接数据库步骤-以eclipse为例" class="headerlink" title="一、连接数据库步骤(以eclipse为例)"></a>一、连接数据库步骤(以eclipse为例)</h1><p>1.首先需要安装一个驱动的jar包。<br>2.然后右键点击所创的Java项目，点击build path之后继续点击Add External Archieves，找到<br>  你安装的jar包，点击打开。<br>3.编写连接数据库的代码，进行增删改查。</p><h1 id="二、连接数据库的Java代码块"><a href="#二、连接数据库的Java代码块" class="headerlink" title="二、连接数据库的Java代码块"></a>二、连接数据库的Java代码块</h1><p>代码如下：<br>Connection con;<br>Statement stmt;<br>ResultSet rs;<br> Class.forName(“com.mysql.jdbc.Driver”);<br>String url=”jdbc:mysql://localhost:3306/student”;<br>con=DriverManager.getConnection(“url”,”root”,”admin”);//root指的是数据库名，admin指的是密码。<br>stmt=con.createStatement();<br>String sql=”sql语句”//select或delete或insert或update语句<br>rs=stmt.exectuteQuery(sql)或者rs=stmt.executeUpdate(sql);</p><h1 id="三、具体实例"><a href="#三、具体实例" class="headerlink" title="三、具体实例"></a>三、具体实例</h1><h2 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h2><p>Connection con;<br>java.sql.Statement stmt;<br>ResultSet rs;<br>try {<br>Class.forName(“com.mysql.jdbc.Driver”);<br>}catch (ClassNotFoundException ex) {<br>System.out.println(“error:”+ex);<br>}<br>try {<br>con=DriverManager.getConnection(“jdbc:mysql://localhost:3306/student”,”student”,”123456”);<br> stmt=con.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE,ResultSet.CONCUR_READ_ONLY);<br> rs=stmt.executeQuery(“select *from sb”);<br>rs.last();<br>int k=rs.getRow();<br> if(k==0) {<br>JOptionPane.showMessageDialog(this,”你查询的表为空表”,”系统提示”,JOptionPane.WARNING_MESSAGE);<br>}<br>rs.beforeFirst();<br>String ob[][]=new String[k][6];<br>for(int i=0;(i&lt;k)&amp;&amp;(rs.next());i++) {<br>ob[i][0]=rs.getString(“sbid”);<br>ob[i][1]=rs.getString(“sblb”);<br>ob[i][2]=rs.getString(“dt”);<br>ob[i][3]=rs.getString(“sname”);<br>ob[i][4]=rs.getString(“sbzt”);<br>ob[i][5]=rs.getString(“sbbm”);<br>}<br>String s[]= {“设备编号”,”设备类别”,”出厂日期”,”设备名称”,”设备状态”,”设备所属部门”};<br>jt=new JTable(ob,s);<br>jt.setSize(700,700);<br>JScrollPane jsp=new JScrollPane(jt);<br>jsp.setPreferredSize(new Dimension(jt.getWidth()-100,jt.getHeight()-100));<br>p1.add(jsp,”Center”);<br>con.close();<br>}catch(Exception e) {<br>e.printStackTrace();<br>}<br>this.add(p1);<br>p1.setVisible(true);<br>this.setVisible(true);<br>}</p><h2 id="增加信息"><a href="#增加信息" class="headerlink" title="增加信息"></a>增加信息</h2><p>Connection conn;<br>Statement stmt;<br>Class.forName(“com.mysql.jdbc.Driver”);<br>conn=DriverManager.getConnection(“jdbc:mysql://localhost:3306/student”,”student”,”123456”);<br>stmt=conn.createStatement();<br>String sbid=jt[0].getText();<br>String sblb= jt[1].getText();<br>String dt=jt[2].getText();<br>String sname=jt[3].getText()；<br>String sbzt=jt[4].getText();<br>String sbbm=jt[5].getText();<br>String sql=”insert into sb “+” (sbid,sblb,dt,sname,sbzt,sbbm)”+”values(‘“+sbid+”‘,’”+sblb+”‘,’”+dt+”‘,’”+sname+”‘,’”+sbzt+”‘,’”+sbbm+”‘)”;<br>stmt.executeUpdate(sql);<br>stmt.close();<br>conn.close();</p><h2 id="删除信息"><a href="#删除信息" class="headerlink" title="删除信息"></a>删除信息</h2><p>Connection conn;<br>Statement stmt;<br>Class.forName(“com.mysql.jdbc.Driver”);<br>conn=DriverManager.getConnection(“jdbc:mysql://localhost:3306/student”,”student”,”123456”);<br>stmt=conn.createStatement();<br>String sbid=jt[0].getText();<br>String sblb= jt[1].getText();<br>String dt=jt[2].getText();<br>String sname=jt[3].getText();<br>String sbzt= jt[4].getText();<br>String sbbm =jt[5].getText();<br>String sql=”delete from sb where sbid=’”+sbid+”‘“;<br>stmt.executeUpdate(sql);<br>stmt.close();<br>conn.close();</p><h2 id="修改信息"><a href="#修改信息" class="headerlink" title="修改信息"></a>修改信息</h2><p>Connection conn;<br>Statement stmt;<br>Class.forName(“com.mysql.jdbc.Driver”);<br>conn=DriverManager.getConnection(“jdbc:mysql://localhost:3306/student”,”student”,”123456”);<br>stmt=conn.createStatement();<br>String sbid=jt[0].getText();<br>String sblb= jt[1].getText();<br>String dt=jt[2].getText();<br>String sname=jt[3].getText();<br>String sbzt=jt[4].getText();<br>String sbbm=jt[5].getText();<br>String sql=”update sb set sbid=’”+sbid+”‘,sblb=’”+sblb+”‘,dt=’”+dt+”‘,sname=’”+sname+”‘,sbzt=’”+sbzt+”‘,sbbm=’”+sbbm+”‘<br>where sbid=’”+sbid+”‘“;<br>stmt.executeUpdate(sql);<br>stmt.close();<br>conn.close();<br>注：本例是以实验室设备信息建表进行增删改查操作，其中查询将得到的信息建表后加入到面板中<br>，然后增删改代码执行过后，通过再次调用查询类查看进行增删改操作后的表信息。本例是为了方便<br>之后Java项目连接数据库。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>贪心算法</title>
      <link href="2021/04/18/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
      <url>2021/04/18/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="一、贪心算法的基本思想"><a href="#一、贪心算法的基本思想" class="headerlink" title="一、贪心算法的基本思想"></a>一、贪心算法的基本思想</h1><p>贪心算法是指在对问题求解时，总是做出在当前看来是最好的选择。也就是说，<br>不从整体最优上加以考虑，它所做出的仅是在某种意义上的局部最优解。用局<br>部解构造全局解，即从问题的某一个初始解逐步逼近给定的目标，以尽可能快<br>的求得更好的解。当某个算法中的某一步不能再继续前进时，算法停止。</p><hr><h1 id="二、贪心算法存在问题"><a href="#二、贪心算法存在问题" class="headerlink" title="二、贪心算法存在问题"></a>二、贪心算法存在问题</h1><p>(1)不能保证解释最佳的。因为贪心算法总是从局部出发，并没有从整体考虑。<br>(2)贪心算法一般用来解决求最大或最小解。<br>(3)贪心算法只能确定某些问题的可行性范围。</p><hr><h1 id="三、贪心算法的实现过程"><a href="#三、贪心算法的实现过程" class="headerlink" title="三、贪心算法的实现过程"></a>三、贪心算法的实现过程</h1><p>贪心算法的核心问题是选择能产生问题最优解的最优度量标准，即贪心策略。<br>所谓贪心策略是指从问题的.初始状态出发，通过若干次的贪心选择而得出最<br>优值的一种解题方法，其具体的实现<br>过程如下：<br>(1)应用同一规则，将原问题变为一个相似的但规模更小的子问题。<br>(2)从问题的某一初始解出发：<br>      while （能朝给定目标前进一步）<br>              求出可行解的一个解元素<br>(3)由所有解元素组合成问题的一个可行解</p><h2 id="四、具体实例"><a href="#四、具体实例" class="headerlink" title="四、具体实例"></a>四、具体实例</h2><p>有N堆纸牌，编号分别为1，2，…，n。每堆上有若干张,但纸牌总数必为n的倍数.<br>可以在任一堆上取若干张纸牌,然后移动。移牌的规则为：在编号为1上取的纸牌，<br>只能移到编号为2的堆上；在编号为n的堆上取的纸牌，只能移到编号为n-1的堆上；<br>其他堆上取的纸牌，可以移到相邻左边或右边的堆上。现在要求找出一种移动方法，<br>用最少的移动次数使每堆上纸牌数都一样多。例如：n=4，4堆纸牌分别为：<br>① 9 ② 8 ③ 17 ④ 6 移动三次可以达到目的：从③取4张牌放到④<br> 再从③区3张放到②然后从②去1张放到①。</p><p>样例输入<br>4<br>9 8 17 6<br>样例输出<br>3</p><p>代码<br>public class Greedy {<br>    public static void main(String[] args) {<br>  int n = 0, avg =0, s = 0;<br>  Scanner scanner = new Scanner(System.in);<br>  ArrayList<Integer> array = new ArrayList<Integer>();<br>  System.out.println(“Please input the number of heaps:”);<br>  n = scanner.nextInt();<br>  System.out.println(“Please input heap number:”);<br>  for (int i = 0; i &lt; n; i++) {<br>   array.add(scanner.nextInt());<br>  }<br>  for(int i = 0; i &lt; array.size(); i ++){<br>   avg += array.get(i);<br>  }<br>  avg = avg/array.size();<br>  System.out.println(array.size());<br>  System.out.println(avg);<br>  for(int i = 0; i &lt; array.size()-1; i ++){<br>   s++;<br>   array.set(i+1, array.get(i+1)+array.get(i)-avg);   <br>  }<br>  System.out.println(“s:” + s);<br> }<br>}</p><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>枚举算法</title>
      <link href="2021/04/17/%E6%9E%9A%E4%B8%BE%E7%AE%97%E6%B3%95/"/>
      <url>2021/04/17/%E6%9E%9A%E4%B8%BE%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="一、枚举算法的思想"><a href="#一、枚举算法的思想" class="headerlink" title="一、枚举算法的思想"></a>一、枚举算法的思想</h1><h2 id="枚举算法的定义"><a href="#枚举算法的定义" class="headerlink" title="枚举算法的定义"></a>枚举算法的定义</h2><p>在进行归纳推理时，如果逐个考察了某类事件的所有可能情况，因而得出一般结论，那么该结论是可靠 的，<br>这种归纳方法叫做枚举法。</p><h2 id="枚举算法的思想"><a href="#枚举算法的思想" class="headerlink" title="枚举算法的思想"></a>枚举算法的思想</h2><p>将问题的所有可能的答案一一列举，然后根据条件判断此答案是否合适，保留合适的，舍弃不合适的。</p><h2 id="使用枚举算法解题的基本思路"><a href="#使用枚举算法解题的基本思路" class="headerlink" title="使用枚举算法解题的基本思路"></a>使用枚举算法解题的基本思路</h2><p>（1）确定枚举对象、范围和判定条件。<br>（2）逐一枚举可能的解并验证每个解是否是问题的解。</p><h2 id="枚举算法步骤"><a href="#枚举算法步骤" class="headerlink" title="枚举算法步骤"></a>枚举算法步骤</h2><p>（1）确定解题的可能范围，不能遗漏任何一个真正解，同时避免重复。<br>（2）判定是否是真正解的方法。<br>（3）为了提高解决问题的效率，使可能解的范围将至最小。</p><hr><h1 id="二、算法实例"><a href="#二、算法实例" class="headerlink" title="二、算法实例"></a>二、算法实例</h1><p>题目描述<br>观察数字：12321，123321都有一个共同的特征，无论从左往右读，还是从右往左读，都是相同的，<br>上述数字称为回文数字。</p><p>现在要从5位或6位的十进制数字中找出各个位数之后等n的回文数字。</p><p>输入格式<br>输入一个整数n(10&lt;n&lt;=100)</p><p>输出格式<br>输出所有个位数之和等于n的5位和6位整数，每个数字占一行，数字从小到大的顺序排列。<br>如果没有满足的数字，则输出-1。<br>样例输入<br>48</p><p>样例输出<br>699996<br>789987<br>798897<br>879978<br>888888<br>897798<br>969969<br>978879<br>987789<br>996699</p><p>代码<br>#include&lt;bits/stdc++.h&gt;<br>using namespace std;<br>int n;<br>int digit[6];<br>bool jug(int x){<br>    int m=0,sum=0;<br>    while(x){<br>        digit[m++]=x%10;<br>        sum+=x%10;<br>        x/=10;<br>    }<br>    if(sum!=n){<br>        return false;<br>    }<br>    for(int i=0;i&lt;m/2;i++){<br>        if(digit[i]!=digit[m-1-i])<br>        return false;<br>    }<br>    return true;<br>}<br>int main(){<br>    bool f=false;<br>    cin&gt;&gt;n;<br>    for(int i=10000;i&lt;1000000;i++){<br>        if(jug(i)){<br>            cout&lt;&lt;i&lt;&lt;endl;<br>            f=true;<br>        }<br>    }<br>    if(!f){<br>        cout&lt;&lt;-1&lt;&lt;endl;<br>    }<br>    return 0;<br>} </p><hr><p>题目描述<br>方程a^2+b^2+c^2=n，其中0&lt;a&lt;b&lt;c。请你求出它的所有解，结果按照<br>a的值从小到大输出。</p><p>输入格式<br>输入一个整数n，为方程等号右边的整数。</p><p>输出格式<br>输出若干行，每行包括三个空格隔开的整数，分别为a,b,c的值。</p><p>样例输入<br>1000</p><p>样例输出<br>6 8 30<br>10 18 24</p><p>代码<br>#include&lt;bits/stdc++.h&gt;<br>using namespace std;<br>int main(){<br>    int n;<br>    cin&gt;&gt;n;<br>    for(int a=1;a * a&lt;=n;a++){<br>        for(int b=a+1;a * a+b * b&lt;=n;b++){<br>            for(int c=b+1;a * a+b * b+c * c&lt;=n;c++){<br>                if(a * a+b * b+c * c==n)<br>                cout&lt;&lt;a&lt;&lt;” “&lt;&lt;b&lt;&lt;” “&lt;&lt;c&lt;&lt;endl;<br>            }<br>        }<br>    }<br>    return  0;<br>}</p><hr><p>题目描述<br>给定一个n x m的矩阵A。求A中的一个非空子矩阵，使这个子矩阵<br>中的元素和最大。其中，A的子矩阵是指A中行和列均连续的一部分。</p><p>输入格式<br>输入的第一行包含两个整数<br>n,m(n&gt;=1,m&lt;=50),分别表示矩阵A的行数和列数，接下来n行，每行<br>m个整数，表示矩阵Aij(-1000&lt;=Aij&lt;=1000)。</p><p>输出格式<br>输出一行，每包含一个整数，表示A中最大的子矩阵中的元素和</p><p>样例输入<br>3 3<br>2 -4 1<br>-1 2 1<br>4 -2 2</p><p>样例输出<br>6</p><p>代码<br>#include&lt;bits/stdc++.h&gt;<br>using namespace std;<br>int A[55][55];<br>int main(){<br>    int n,m,ans;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    ans=-1005;<br>    for(int i=0;i&lt;n;i++){<br>        for(int j=0;j&lt;m;j++){<br>            cin&gt;&gt;A[i][j];<br>        }<br>    }<br>    for(int i=0;i&lt;n;i++){<br>        for(int j=i;j&lt;n;j++){<br>            for(int k=0;k&lt;m;k++){<br>                for(int l=k;l&lt;m;l++){<br>                    int tmp=0;<br>                    for(int p=i;p&lt;=j;p++){<br>                        for(int q=k;q&lt;=l;q++){<br>                            tmp+=A[p][q];<br>                        }<br>                    }<br>                    if(tmp&gt;ans){<br>                        ans=tmp;<br>                    }<br>                }<br>            }<br>        }<br>    }<br>    cout&lt;&lt;ans&lt;&lt;endl;<br>    return  0;<br>}</p><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++算法常用函数</title>
      <link href="2021/04/16/C-%E7%AE%97%E6%B3%95%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
      <url>2021/04/16/C-%E7%AE%97%E6%B3%95%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><p>string.find(string a,pos)a是子字符串，pos是查找开始的位置，不填的话默认为0，这里<br>要注意，如果不存在要找到的东西，则返回string.npos；<br>string.length()返回string长度<br>string.substr(int start,int length)start是子字符串开始的位置，lenth是子字符串的长度;<br>string.resize(int)resize可以初始化string的大小，可以让string使用scanf以及类似char[];<br>的操作；</p><hr><h2 id="char大小写转换"><a href="#char大小写转换" class="headerlink" title="char大小写转换"></a>char大小写转换</h2><p>变为大写:char =toupper(char);<br>变为小写:char =tolower(char);<br>注:在头文件#include&lt;ctype.h&gt;下使用</p><hr><p>##字符串<br>to_string():将数字转换为string类型<br>reverse(y1,y2):将y1到y2范围的元素翻转<br>string.c.str():返回一个指向正规C字符串的指针，内容与本string串相同;<br>atoi:把一字符串转换为整数int atoi(const char *nptr);<br>对于string类型需要atoi(str.c_str))</p><hr><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>fill(a,a+n,6)将数组下标为0~n-1的元素赋值为6<br>next_permutation(a,a+n)全排列<br>sort(arr,arr+n)快速排序，默认从小到大</p><hr><h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><p>vector.size() 返回vector的大小<br>vector.push_back(Elem) 在vector的最后压入元素；<br>vector.pop_back() 删除vector中最后一个元素；<br>vector.assign(begin, end) 清空容器，进行赋值操作；</p><hr><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>set.insert(Elem) 在set中插入元素；<br>set.size() 返回set的大小<br>set.find(Elem) 如果找到返回迭代器，如果没有找到，返回set.end();<br>遍历set的操作:<br>set<T>::iterator iter = set.begin();<br>for(;iter!=set.end();iter++){<br>    //do something<br>    cout&lt;&lt;*iter&lt;&lt;endl;<br>}</p><hr><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>map[Elem1]=Elem2在map中以数组的方式插入数据<br>map.find(Elem)查找成功返回iterator，失败则返回map.end();<br>map中每个元素的本质其实是pair&lt;Elem1, Elem2&gt;；pair是可以使用pair.first和pair.second<br>来表示第一个元素和第二个元素；当使用迭代器时，(*iterator).first是map的key，<br>(*iterator).second是map的value值；而在排序的时候，是无法直接对map使用sort，<br>我们可以考虑将map先转化为vector&lt;pair&lt;Elem1, Elem2&gt;&gt;来进行自定义排序。<br>其中，map和vector的转换代码为:<br>vector&lt;pair&lt;Elem1, Elem2&gt;&gt; temp(map.begin(),map.end());</p><hr><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><p>sort(a, a+length) a为第一个元素地址，length为需要排序的元素个数；<br>sort(vector.begin(), vector.end()) 这是vector排序；<br>sort(a, a+length, cmp) 其中cmp是自定一个的函数（bool cmp(a, b)）；<br>reverse(a, a+length) a为第一个元素地址，length为需要逆转的元素个数；<br>swap(a, b) 其中a，b可以是容器，可以是变量；<br>find(a, a+length, val) a为第一个元素的地址，length为查找范围，val是查找到值；<br>copy(a, a+length, b) a为输入元素地址，length为复制范围，b为输出元素首地址；<br>fill(a, a+length, val) a为初始化元素首地址，length为初始化范围，val为全部初始化的值；<br>注:在头文件 #include&lt; algorithm&gt;下使用</p><hr><h2 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h2><p>fabs(double)取double的绝对值<br>abs(int)取int的绝对值<br>round(double)对double类型的四舍五入<br>sqrt(double)返回double的算术平方根<br>注:在头文件#include&lt;math.h&gt;下使用</p><hr><h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><p>ceil(double a):向上取整<br>floor(double a):向下取整<br>count()存在于vector和string中，分别对单个数字和单个字符计数<br>count(v.begin,v.end(),n)统计v中n出现的个数</p><hr><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>sort(a, a+length) 一般是将a按照ascii码的顺序排序；<br>sort(a, a+length, cmp) 是需要自定义排序时候，按照自定义的方法排序；<br>cmp自定义函数示例如下:<br>//按照从小到大排序；<br>//其中假定是将vector<string> 排序，因此参数为string a和string b；<br>bool cmp(string a, string b){<br>    return a&lt;b;<br>}</p><hr><h2 id="最大值和最小值"><a href="#最大值和最小值" class="headerlink" title="最大值和最小值"></a>最大值和最小值</h2><p>int num[]={2,3,1,6,4,5};<br>cout&lt;&lt;”最小值是 “&lt;&lt;*min_element(num,num+6)&lt;&lt;endl;<br>cout&lt;&lt;”最大值是 “&lt;&lt;<em>max_element(num,num+6)&lt;&lt;endl;<br>//注意这个</em>，因为返回的是迭代器；<br>注:max(),min()分别求最大值与最小值</p><h2 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h2><p>int gcd(int a, int b){<br>    return b == 0 ? a : gcd(b, a % b);<br>}</p><hr><h2 id="最小公倍数"><a href="#最小公倍数" class="headerlink" title="最小公倍数"></a>最小公倍数</h2><p>int c = gcd(a, b);//最小公倍数可以利用最大公约数；<br>int lcm(int a, int b){<br>    return a*b/c;<br>}</p><hr><h2 id="set和vector之间的相互转化"><a href="#set和vector之间的相互转化" class="headerlink" title="set和vector之间的相互转化"></a>set和vector之间的相互转化</h2><p>//set初始化vector<br>vector.assign(set.begin, set.end());<br>//vector初始化set<br>set(vector.begin(), vector.end());</p><hr><h2 id="大数据的处理"><a href="#大数据的处理" class="headerlink" title="大数据的处理"></a>大数据的处理</h2><p>绝对值在10^9以内的整数要用int；<br>超过2*10^9要用long（10^18以内）；</p><hr><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><p>如果是多循环的输入输出，一般使用scanf和printf，这样会提高很多效率，以防止时间限制；<br>如果是输入输出单个固定，可以使用cin和cout；<br>如果需要格式的输出，一定使用printf；<br>万能头文件: #include&lt;bits/stdc++.h&gt;</p><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>KMP</title>
      <link href="2021/04/16/KMP/"/>
      <url>2021/04/16/KMP/</url>
      
        <content type="html"><![CDATA[<h1 id="一、KMP算法"><a href="#一、KMP算法" class="headerlink" title="一、KMP算法"></a>一、KMP算法</h1><p>在KMP算法中，对于每一个模式串都会事先计算出模式串的内部匹配信息，在匹配失败时最大的移动模式串，<br>以减少匹配次数，这样就很好的解决了BF算法的缺陷比如，当匹配失败后，最好是能够将模式字串尽量的右移<br>和主串进行匹配，右移的距离在KMP算法中是这样计算的：在已经匹配的字串中，找到最长的相同的前缀和后缀，<br>然后移动使他们重叠，这个位置就是j要回退的位置，这样j就不用每一次都回到0号位置了，每一次j回退的位置存<br>储在一个数组里，称之为next数组。</p><hr><h1 id="二、具体实现"><a href="#二、具体实现" class="headerlink" title="二、具体实现"></a>二、具体实现</h1><p>获取next数组<br>代码<br>void GetNext(int *next,const char *sub)<br>{<br>    next[0] = -1;<br>    next[1] = 0;<br>    int lensub = strlen(sub);<br>    int i = 2;//当前的i<br>    int k = 0;//前一项的K值<br>    while(i &lt; lensub)<br>    {<br>        if(k == -1 || sub[i-1] == sub[k])<br>        {<br>            next[i] = k+1;<br>            i++;<br>            k = k+1;<br>        }<br>        else<br>        {<br>            k  = next[k];<br>        }<br>    }<br>}<br>算法实现<br>int Kmp(const char *str,const char *sub,int pos)<br>{<br>    int i = pos;<br>    int j = 0;<br>    int lens = strlen(str);<br>    int lensub = strlen(sub);<br>    int *next = (int *)malloc(sizeof(int) * lensub);<br>    assert(next != NULL);<br>    GetNext(next,sub);<br>    while(j &lt; lensub &amp;&amp; i &lt; lens)<br>    {<br>        if(j == -1 || str[i] == sub[j])<br>        {<br>            i++;<br>            j++;<br>        }<br>        else<br>        {<br>            j = next[j];<br>        }<br>    }<br>    if(j &gt;= lensub)<br>    {<br>        return i-j;<br>    }<br>    else<br>    {<br>        return -1;<br>    }<br>}</p><hr><h1 id="三、实例"><a href="#三、实例" class="headerlink" title="三、实例"></a>三、实例</h1><p>题目描述<br>首先输入一行字符串，然会在输入一行子串，输出对应的next数组与子串首位在原字符串的位置</p><p>样例输入<br>sdryteygdgdyhusjk<br>eygdg</p><p>样例输出<br>next:-1 0 0 0 0<br>5<br>代码<br>#include&lt;stdio.h&gt;<br>#include&lt;string.h&gt;<br>typedef struct seqstring {<br>    char string[100];<br>    int length;<br>}seqstring;<br>void getnext(seqstring p, int next[]) {<br>    int i, j;<br>    i = 0;//指向字符串每个字符的下标<br>    j = -1;<br>    next[i] = j;//next[0]放上-1<br>    while (i &lt; p.length) {//没有到达结尾的话<br>        if (j == -1 || p.string[i] == p.string[j]) {//如果是第一个字符或遇到相同的字符<br>            next[++i] = ++j;<br>        }<br>        else {<br>            j = next[j];<br>        }<br>    }<br>    for (i = 0;i &lt; p.length;i++) {//输出next[]值<br>        printf(“%d “, next[i]);<br>    }<br>}<br>int kmp(seqstring t, seqstring p, int next[]) {<br>    int i, j;<br>    i = j = 0;<br>    while (i &lt; t.length &amp;&amp; j &lt; p.length) {<br>        if (j == -1 || t.string[i] == p.string[j]) {<br>            i++;j++;<br>        }<br>        else {<br>            j = next[j];<br>        }<br>    }<br>    if (j == p.length) return i - p.length;<br>    else return -1;<br>}<br>int  main() {<br>    seqstring t, p;<br>    int next[50];<br>    scanf(“%s”, t.string);<br>    t.length = strlen(t.string);<br>    scanf(“%s”, p.string);<br>    p.length = strlen(p.string);<br>    printf(“next:”);<br>    getnext(p, next);<br>    printf(“\n%d\n”, kmp(t, p, next));<br>    return 0;<br>}</p><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>BF</title>
      <link href="2021/04/16/BF/"/>
      <url>2021/04/16/BF/</url>
      
        <content type="html"><![CDATA[<h1 id="一、BF算法"><a href="#一、BF算法" class="headerlink" title="一、BF算法"></a>一、BF算法</h1><p>暴力匹配(BF)算法是普通的模式匹配算法，BF算法的思想就是将目标串S的第一个字符与模式串T的第一个字符<br>与模式串的T的第一个字符进行匹配，若相等，则继续比较S的第二个和T的第二个字符；若不等，则继续比较S<br>的第二个字符和T的第一个字符，依次比较，直到得到最后的匹配结果。</p><hr><h1 id="二、具体实现"><a href="#二、具体实现" class="headerlink" title="二、具体实现"></a>二、具体实现</h1><p>下标从0开始匹配<br>int BF(const char *str,const char *sub,int pos)<br>{<br>    assert(str!=NULL&amp;&amp;sub!=NULL);<br>    int i=pos;//用i来记录S中字符的位置<br>    int j=0;//用j来记录T中字符的位置<br>    int lens=strlen(str);<br>    int lensub=strlen(sub);<br>    //当S不为空并且T不为空时，逐个进行字符的比较<br>    while(j&lt;lensub&amp;&amp;i&lt;lens)<br>    {<br>        if(str[i]==sub[i])<br>        //当S中第i个字符与T中第j个字符相等时，i向后移一个，j向后移一个<br>        {<br>            i++;<br>            j++;<br>        }<br>        else<br>        //当S中第i个字符与T中第i个字符不相等时，i回到前一个位置的下一个位置，j回到0号位置<br>        {<br>            i=i-j+1;<br>            j=0;<br>        }<br>    }<br>    if(j&gt;=lensub)   //当j走完T的长度时，也就说明T在S中匹配成功<br>    {<br>        return i-j;     //此时返回字串在主串中的下标位置，此时i在该返回下标位置+j的长度位置，所以返回i-j。<br>    }<br>    else return -1;  //匹配失败，则返回-1，因为-1下标不存在，不能返回0下标<br>}<br>下标从任意位置开始匹配<br>int BF(SString S,SString T,int pos)<br>{<br>  int i,j;<br>  i=pos;<br>  j=1;<br>  while(i&lt;=S.lenth&amp;&amp;j&lt;=T.lenth) //当检索位置i,j同时小于主串与子串长度时，执行循环<br>   {<br>    if(S.ch[i-1]==T.ch[i-1])<br>     {<br>      i++;<br>      j++;<br>     }<br>    else<br>    {<br>    i=i-j+2;<br>    j=1;<br>    }<br>if(j&gt;T.lenth)<br>   return i-T.lenth; //j&gt;T.lenth匹配成功<br>else<br>    return 0;  //否则匹配失败<br>}</p><hr><h1 id="三、实例"><a href="#三、实例" class="headerlink" title="三、实例"></a>三、实例</h1><p>题目描述<br>首先输入一行字符串，然会在输入一行子串，输出子串首位在原串的位置</p><p>样例输入<br>adsffgshgh<br>ffgsh<br>样例输出<br>4</p><p>代码：<br>#include&lt;stdio.h&gt;<br>#include&lt;stdlib.h&gt;<br>#include&lt;string.h&gt;<br>#define MAXSIZE 100<br>#define OK 1<br>#define ERROR 0<br>typedef struct<br>{<br> char ch[MAXSIZE+1];<br> int length;<br>}SString;           //定义串结构<br>int Index_BF(SString S,SString T,int pos);<br>int main()<br>{<br> int pos = 1,pos_i;<br> SString S,T;<br> gets(S.ch);<br> S.length = strlen(S.ch);<br> gets(T.ch);<br> T.length = strlen(T.ch);<br> pos_i = Index_BF(S,T,pos);      //调用函数获得第一次匹配到的位置<br> printf(“%d”,pos_i);<br> return 0;<br>}<br>int Index_BF(SString S,SString T,int pos)<br>{<br> int i,j;<br> i = pos;<br> j = 1;<br> while(i&lt;=S.length &amp;&amp; j&lt;=T.length)    //当检索位置i,j同时小于主串与子串长度时，执行循环<br> {<br>  if(S.ch[i-1] == T.ch[j-1])<br>  {<br>   i++;<br>   j++;<br>  }<br>  else<br>  {<br>   i = i-j+2;       //匹配不成功，主串回溯到i-j+2,比较后继字符<br>   j = 1;         //匹配不成功，子串回溯到j = 1<br>  }<br> }<br> if(j&gt;T.length)<br>  return i-T.length;      //j&gt;T.length匹配成功<br> else<br>  return 0;        //否则，匹配失败<br>}</p><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>DFS</title>
      <link href="2021/04/16/DFS/"/>
      <url>2021/04/16/DFS/</url>
      
        <content type="html"><![CDATA[<h1 id="一、DFS算法定义"><a href="#一、DFS算法定义" class="headerlink" title="一、DFS算法定义"></a>一、DFS算法定义</h1><p>深度优先搜素算法，又称DFS。DFS算法是一种搜索算法，此算法在运用时就是找一个头结点，然后沿着这个<br>头结点一直找下去，直到找到最后一个满足条件的分节点，然后再寻找另一条路径，当沿着一条路走不满足条<br>件时会自动跳入上一层节点进行判断。DFS算法是递归算法的一种。</p><hr><h1 id="二、DFS算法具体实现"><a href="#二、DFS算法具体实现" class="headerlink" title="二、DFS算法具体实现"></a>二、DFS算法具体实现</h1><p>void DFS(type n){<br>         if(符合条件){cout&lt;&lt;答案;return;}<br>         if(可以剪枝) return;<br>         for(i:1~p){<br>               选择可行决策;<br>               标记已访问该点;<br>               DFS(n+1);<br>               (还原访问现场;)<br>       }<br>}</p><p>int check(参数)<br>{<br>    if(满足条件)<br>        return 1;<br>    return 0;<br>}</p><p>void dfs(int step)<br>{<br>        判断边界<br>        {<br>            相应操作<br>        }<br>        尝试每一种可能<br>        {<br>               满足check条件<br>               标记<br>               继续下一步dfs(step+1)<br>               恢复初始状态（回溯的时候要用到）<br>        }<br>}   </p><hr><h1 id="三、剪枝"><a href="#三、剪枝" class="headerlink" title="三、剪枝"></a>三、剪枝</h1><p>1.顺序性剪枝<br>若一些题的搜索顺序对答案无影响，那么搜索顺序的不同会导致搜索树形态的改变，优先搜索分支较少的阶段，<br>此时能减少搜索的规模。<br>2.重复性剪枝<br>在搜索的时候如果有多种方式可以达到一个状态，那么我们只需要搜索一个分支足矣<br>3.可行性剪枝<br>可行性剪枝是对搜索正确性的一个保证，当分支在递归边界的时候回溯。<br>4.最优性剪枝<br>在搜索过程中，如果当前阶段的代价已经超过我们已知的最小代价，那么此时继续搜索下去没有意义。<br>5.记忆化剪枝<br>记忆搜索状态的结果，当重复遍历一个状态的时候就可以直接返回这个状态的答案，避免重复的搜索。</p><hr><h1 id="四、实例"><a href="#四、实例" class="headerlink" title="四、实例"></a>四、实例</h1><p>1.全排列问题<br>题目描述<br>对输入的多个数进行全排列</p><p>样例输入<br>1 2 3</p><p>样例输出<br>1<br>12<br>21<br>123<br>132<br>213<br>231<br>312<br>321</p><p>代码<br>#include&lt;bits/stdc++.h&gt;<br>using namespace std;<br>int n;<br>int book[10] = {0};<br>int a[10];<br>void dfs(int index)<br>{<br>    if(index == n)  //递归终止条件<br>    {<br>        for(int i = 0;i &lt; n;++i)<br>            cout &lt;&lt; a[i];<br>        cout &lt;&lt; endl;<br>        return ;<br>    }<br>    else<br>    {<br>        for(int i = 1;i &lt;= n;++i)<br>        {<br>            if(!book[i])<br>            {<br>                book[i] = 1;//标记位<br>                a[index] = i;//把符合的数字保存到数组中<br>                dfs(index+1);<br>                a[index] = 0;<br>                book[i] = 0;//还原标记，以便回溯<br>            }<br>        }<br>    }<br>}<br>void init()<br>{<br>    for(int i = 0;i &lt; 9;++i)<br>        book[i] = 0;<br>}<br>int main()<br>{<br>    while(cin &gt;&gt; n)<br>    {<br>        dfs(0);<br>        init();<br>    }<br>    return 0;<br>} </p><hr><p>2.八皇后问题<br>题目描述<br>在国际象棋中，皇后是最厉害的棋子，可以横走、直走，还可以斜走。棋手马克斯·贝瑟尔 1848 年提出著名的八皇后问题：<br>即在 8 × 8 的棋盘上摆放八个皇后，使其不能互相攻击 —— 即任意两个皇后都不能处于同一行、同一列或同一条斜线上。<br>现在我们把棋盘扩展到 n×n 的棋盘上摆放 n 个皇后，请问该怎么摆？<br>请编写程序，输入正整数 n，输出全部摆法（棋盘格子空白处显示句点“.”，皇后处显示字母“Q”，每两个字符之间空一格）。</p><p>输入格式<br>正整数 n(n&gt;0)</p><p>输出格式<br>若问题有解，则输出全部摆法（每两种摆法之间空一行）。<br>若问题无解，则输出 None。<br>要求：试探的顺序按从上到下逐行进行，其中每一行按从左到右的逐格进行</p><p>样例输入1<br>3<br>样例输出1<br>none</p><p>样例输入2<br>6<br>样例输出2<br>. Q . . . .<br>. . . Q . .<br>. . . . . Q<br>Q . . . . .<br>. . Q . . .<br>. . . . Q .</p><p>. . Q . . .<br>. . . . . Q<br>. Q . . . .<br>. . . . Q .<br>Q . . . . .<br>. . . Q . .</p><p>. . . Q . .<br>Q . . . . .<br>. . . . Q .<br>. Q . . . .<br>. . . . . Q<br>. . Q . . .</p><p>. . . . Q .<br>. . Q . . .<br>Q . . . . .<br>. . . . . Q<br>. . . Q . .<br>. Q . . . .</p><p>代码<br>#include&lt;bits/stdc++.h&gt;<br>using namespace std;<br>const int  N=20;<br>char    ch[N][N];//用一个二维数组来存储皇后放置的位置<br>bool   col[N],l[N&lt;&lt;1],r[N&lt;&lt;1];//为了数组不会越界，就把N乘2了,涉及位运算了<br>bool mark;//设置一个变量，判断是否有解（有解输出排法，无解输出None）<br>int  n;<br>//这个dfs是按行逐渐进行下去的，初始值为0行<br>void dfs(int x)<br>{<br>//如果x能够来到从初始值0来到n的位置就说明有一个解已经产生<br>   if(x==n){<br>/*<br>加这个判断实属必要，当第一个解产生的时候，此时mark还是初始值false(0),<br>所以把mark进入判断的第二个作用域，赋值为true(1),如果还有第二个解，<br>此时的mark已经为true，所以输出换行，看到这里是不是有些明白了，对，没错！<br>这个判断就是为了“解”与“解”之间能有个换行符而存在的！<br>*/<br>       if(mark)<br>       {<br>       cout&lt;&lt;endl;<br>       }<br>       else<br>       {<br>       mark=1;<br>       }<br>//下面就是遍历这个“解”了<br>for(int i=0;i&lt;n;i++)<br> {<br>   for(int j=0;j&lt;n;j++)<br>   {<br>    cout&lt;&lt;ch[i][j];<br>     if(j!=n-1)<br>     {<br>       cout&lt;&lt;’ ‘;//处理字符与字符之间的空格<br>     }<br>   }<br>  putchar(10);//输出一行后需要换行，换行的ASCII数为10<br> }<br>return;<br>       }//当这个“解”遍历完的时候，可以安排它消亡了<br>         //下面代码是这个题的核心，请务必！务必！务必！要不择一切手段也要弄懂<br>/*<br>要明白下面的for循环的意思，记住是x代表行数，下面的i代表的是x行i列,<br>如果不明白，请反复看，已经是保姆式教学了，<br>*/<br>  for(int i=0;i&lt;n;i++)<br> {<br>//下面的判断是核心中核心:<br>//第一个判断col[i]是判断i列能不能放，col[i]=1,说明不能放（因为下面的判断是！col[i]）<br>//第二个判断l[x+i]是判断主对角线能不能放，<br>//第三个判断r[n-x+i]是判断副对角线能不能放，<br>//第二第三个如果不能理解，建议直接强记模板！<br>     if(!col[i]&amp;&amp;!l[x+i]&amp;&amp;!r[n-x+i])<br>    {<br>    col[i]=l[x+i]=r[n-x+i]=1;//如果能放，对状态进行标记<br>    ch[x][i]=’Q’;<br>    dfs(x+1);//第一行结束，对下一行进行判断,都x+1了，你说是不是下一行<br>//对该坐标进行归“零”处理<br>     ch[x][i]=’.’;<br>    col[i]=l[x+i]=r[n-x+i]=0;<br>     }<br>  }<br>}<br>int main()<br>{<br>//这个就是对数组进行初始化处理，如果不知道的建议搜memset()详解<br>memset(ch,’.’,sizeof(ch));//初始化地图数组,这个函数在cstring这个头文件下面<br>cin&gt;&gt;n;<br>dfs(0);//这个就没得说了，从第一行开始遍历，0就是第一行。<br>//无解就输出None咯！<br>if(!mark)<br>{<br>    cout&lt;&lt;”None”;<br>}<br>return 0;<br>}</p><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>排序</title>
      <link href="2021/04/14/%E6%8E%92%E5%BA%8F/"/>
      <url>2021/04/14/%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>题目描述<br>对输入的n个数进行从小到大排序</p><p>样例输入<br>5<br>1 3 2 5 4<br>样例输出<br>1 2 3 4 5</p><hr><h2 id="冒泡法"><a href="#冒泡法" class="headerlink" title="冒泡法"></a>冒泡法</h2><p>代码：<br>#include&lt;stdio.h&gt;<br>int main(){<br>int a[100];<br>int i,j,n,t;<br>scanf(“%d”,&amp;n);<br>for(i=0;i&lt;n;i++){<br>scanf(“%d”,&amp;a[i]);<br>}<br>for(j=0;j&lt;n-1;j++){<br>  for(i=0;i&lt;n-1-j;i++){<br>    if(a[i]&gt;a[i+1])<br>    {<br>     t=a[i];<br>     a[i]=a[i+1];<br>     a[i+1]=t;<br>    }<br>  }<br>}<br>for(i=0;i&lt;n;i++){<br>printf(“%d “,a[i]);<br>}<br>return 0;<br>}</p><hr><h2 id="选择法"><a href="#选择法" class="headerlink" title="选择法"></a>选择法</h2><p>代码：<br>#include&lt;stdio.h&gt;<br>int main(){<br>int a[100];<br>int i,j,k,n,t;<br>scanf(“%d”,&amp;n);<br>for(i=0;i&lt;n;i++){<br>scanf(“%d”,&amp;a[i]);<br>}<br>for(i=0;i&lt;n;i++){<br>    k=i;<br>    for(j=i+1;j&lt;n;j++){<br>        if(a[k]&gt;a[j])<br>        k=j;<br>        if(k!=i)<br>        {<br>            t=a[i];<br>            a[i]=a[k];<br>            a[k]=t;<br>        }<br>    }<br>}<br>for(i=0;i&lt;n;i++){<br>printf(“%d “,a[i]);<br>}<br>return 0;<br>}</p><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客文章</title>
      <link href="2021/04/11/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/"/>
      <url>2021/04/11/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p>代码：<br>#include&lt;stdio.h&gt;<br>int main()<br>{<br>printf(“hello world”)<br>return 0;<br>}</p><hr><h2 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h2><p>代码：<br>#include&lt;bits/stdc++.h&gt;<br>using namespace std;<br>int main()<br>{<br>cout&lt;&lt;”hello world”;<br>return 0;<br>}</p><hr><h2 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h2><p>代码：<br>public class helloworld{<br>      public static void main(String args[]{<br>             System.out.println(“hello world”);<br>    }<br>}</p><hr><h2 id="PYTHON"><a href="#PYTHON" class="headerlink" title="PYTHON"></a>PYTHON</h2><p>代码：<br>print(“hello world”)</p><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/04/11/hello-world/"/>
      <url>2021/04/11/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
